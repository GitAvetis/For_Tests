================================================
FILE: src/.gitkeep
================================================
[Empty file]


================================================
FILE: src/ProjectTeam01/game_save.json
================================================
{
  "Hero": {
    "PosX": 7,
    "PosY": 13,
    "CurrentHp": 71,
    "BaseMaxHp": 150,
    "BaseStrength": 5,
    "BaseAgility": 5,
    "ActiveEffects": [],
    "HeroBackpack": [
      {
        "Type": 0,
        "PosX": 12,
        "PosY": 13,
        "GameLevel": 0,
        "Price": 15
      },
      {
        "Type": 1,
        "PosX": 13,
        "PosY": 13,
        "GameLevel": 0,
        "HealthValue": 18
      },
      {
        "Type": 1,
        "PosX": 2,
        "PosY": 13,
        "GameLevel": 0,
        "HealthValue": 9
      },
      {
        "Type": 2,
        "PosX": 21,
        "PosY": 13,
        "GameLevel": 0,
        "ElixirType": 2
      },
      {
        "Type": 2,
        "PosX": 11,
        "PosY": 13,
        "GameLevel": 0,
        "ElixirType": 1
      },
      {
        "Type": 3,
        "PosX": 40,
        "PosY": 13,
        "GameLevel": 0,
        "ScrollType": 2
      }
    ],
    "IsHeroSleep": false
  },
  "Enemies": [
    {
      "EnemyType": 4,
      "PosX": 11,
      "PosY": 7,
      "ActualHp": 100,
      "IsTriggered": false
    },
    {
      "EnemyType": 4,
      "PosX": 13,
      "PosY": 25,
      "ActualHp": 100,
      "IsTriggered": false
    },
    {
      "EnemyType": 2,
      "PosX": 44,
      "PosY": 24,
      "ActualHp": 100,
      "IsTriggered": false,
      "IsInvisible": true
    },
    {
      "EnemyType": 0,
      "PosX": 47,
      "PosY": 26,
      "ActualHp": 150,
      "IsTriggered": false
    }
  ],
  "Items": [
    {
      "Type": 2,
      "PosX": 74,
      "PosY": 14,
      "GameLevel": 0,
      "ElixirType": 0
    },
    {
      "Type": 3,
      "PosX": 72,
      "PosY": 15,
      "GameLevel": 0,
      "ScrollType": 2
    },
    {
      "Type": 3,
      "PosX": 22,
      "PosY": 6,
      "GameLevel": 0,
      "ScrollType": 1
    },
    {
      "Type": 4,
      "PosX": 7,
      "PosY": 5,
      "GameLevel": 0,
      "WeaponType": 3
    },
    {
      "Type": 4,
      "PosX": 79,
      "PosY": 15,
      "GameLevel": 0,
      "WeaponType": 0
    },
    {
      "Type": 1,
      "PosX": 76,
      "PosY": 23,
      "GameLevel": 0,
      "HealthValue": 11
    },
    {
      "Type": 1,
      "PosX": 72,
      "PosY": 16,
      "GameLevel": 0,
      "HealthValue": 18
    },
    {
      "Type": 1,
      "PosX": 3,
      "PosY": 7,
      "GameLevel": 0,
      "HealthValue": 16
    },
    {
      "Type": 2,
      "PosX": 20,
      "PosY": 25,
      "GameLevel": 0,
      "ElixirType": 2
    }
  ],
  "Level": {
    "LevelNumber": 1,
    "Rooms": [
      {
        "Sector": 0,
        "TopLeft": {
          "X": 1,
          "Y": 1
        },
        "BottomRight": {
          "X": 27,
          "Y": 8
        },
        "Doors": [
          {
            "X": 25,
            "Y": 8
          }
        ],
        "IsStartRoom": false,
        "IsEndRoom": false
      },
      {
        "Sector": 1,
        "TopLeft": {
          "X": 42,
          "Y": 1
        },
        "BottomRight": {
          "X": 56,
          "Y": 5
        },
        "Doors": [
          {
            "X": 56,
            "Y": 3
          },
          {
            "X": 48,
            "Y": 5
          }
        ],
        "IsStartRoom": true,
        "IsEndRoom": false
      },
      {
        "Sector": 2,
        "TopLeft": {
          "X": 61,
          "Y": 1
        },
        "BottomRight": {
          "X": 88,
          "Y": 8
        },
        "Doors": [
          {
            "X": 61,
            "Y": 6
          }
        ],
        "IsStartRoom": false,
        "IsEndRoom": false
      },
      {
        "Sector": 3,
        "TopLeft": {
          "X": 1,
          "Y": 11
        },
        "BottomRight": {
          "X": 28,
          "Y": 16
        },
        "Doors": [
          {
            "X": 11,
            "Y": 11
          },
          {
            "X": 28,
            "Y": 15
          }
        ],
        "IsStartRoom": false,
        "IsEndRoom": false
      },
      {
        "Sector": 4,
        "TopLeft": {
          "X": 37,
          "Y": 12
        },
        "BottomRight": {
          "X": 56,
          "Y": 17
        },
        "Doors": [
          {
            "X": 38,
            "Y": 12
          },
          {
            "X": 48,
            "Y": 17
          },
          {
            "X": 37,
            "Y": 13
          }
        ],
        "IsStartRoom": false,
        "IsEndRoom": false
      },
      {
        "Sector": 5,
        "TopLeft": {
          "X": 64,
          "Y": 12
        },
        "BottomRight": {
          "X": 80,
          "Y": 17
        },
        "Doors": [
          {
            "X": 70,
            "Y": 17
          }
        ],
        "IsStartRoom": false,
        "IsEndRoom": false
      },
      {
        "Sector": 6,
        "TopLeft": {
          "X": 4,
          "Y": 21
        },
        "BottomRight": {
          "X": 21,
          "Y": 28
        },
        "Doors": [
          {
            "X": 21,
            "Y": 22
          }
        ],
        "IsStartRoom": false,
        "IsEndRoom": false
      },
      {
        "Sector": 7,
        "TopLeft": {
          "X": 36,
          "Y": 23
        },
        "BottomRight": {
          "X": 53,
          "Y": 27
        },
        "Doors": [
          {
            "X": 47,
            "Y": 23
          },
          {
            "X": 53,
            "Y": 26
          },
          {
            "X": 36,
            "Y": 25
          }
        ],
        "IsStartRoom": false,
        "IsEndRoom": false
      },
      {
        "Sector": 8,
        "TopLeft": {
          "X": 73,
          "Y": 21
        },
        "BottomRight": {
          "X": 80,
          "Y": 28
        },
        "Doors": [
          {
            "X": 76,
            "Y": 21
          },
          {
            "X": 73,
            "Y": 22
          }
        ],
        "IsStartRoom": false,
        "IsEndRoom": true
      }
    ],
    "Corridors": [
      {
        "Type": 3,
        "Points": [
          {
            "X": 25,
            "Y": 8
          },
          {
            "X": 25,
            "Y": 9
          },
          {
            "X": 11,
            "Y": 9
          },
          {
            "X": 11,
            "Y": 11
          }
        ],
        "Cells": [
          {
            "X": 25,
            "Y": 8
          },
          {
            "X": 25,
            "Y": 9
          },
          {
            "X": 24,
            "Y": 9
          },
          {
            "X": 23,
            "Y": 9
          },
          {
            "X": 22,
            "Y": 9
          },
          {
            "X": 21,
            "Y": 9
          },
          {
            "X": 20,
            "Y": 9
          },
          {
            "X": 19,
            "Y": 9
          },
          {
            "X": 18,
            "Y": 9
          },
          {
            "X": 17,
            "Y": 9
          },
          {
            "X": 16,
            "Y": 9
          },
          {
            "X": 15,
            "Y": 9
          },
          {
            "X": 14,
            "Y": 9
          },
          {
            "X": 13,
            "Y": 9
          },
          {
            "X": 12,
            "Y": 9
          },
          {
            "X": 11,
            "Y": 9
          },
          {
            "X": 11,
            "Y": 10
          }
        ]
      },
      {
        "Type": 0,
        "Points": [
          {
            "X": 56,
            "Y": 3
          },
          {
            "X": 59,
            "Y": 3
          },
          {
            "X": 59,
            "Y": 6
          },
          {
            "X": 61,
            "Y": 6
          }
        ],
        "Cells": [
          {
            "X": 56,
            "Y": 3
          },
          {
            "X": 57,
            "Y": 3
          },
          {
            "X": 58,
            "Y": 3
          },
          {
            "X": 59,
            "Y": 3
          },
          {
            "X": 59,
            "Y": 4
          },
          {
            "X": 59,
            "Y": 5
          },
          {
            "X": 59,
            "Y": 6
          },
          {
            "X": 60,
            "Y": 6
          }
        ]
      },
      {
        "Type": 3,
        "Points": [
          {
            "X": 48,
            "Y": 5
          },
          {
            "X": 48,
            "Y": 11
          },
          {
            "X": 38,
            "Y": 11
          },
          {
            "X": 38,
            "Y": 12
          }
        ],
        "Cells": [
          {
            "X": 48,
            "Y": 5
          },
          {
            "X": 48,
            "Y": 6
          },
          {
            "X": 48,
            "Y": 7
          },
          {
            "X": 48,
            "Y": 8
          },
          {
            "X": 48,
            "Y": 9
          },
          {
            "X": 48,
            "Y": 10
          },
          {
            "X": 48,
            "Y": 11
          },
          {
            "X": 47,
            "Y": 11
          },
          {
            "X": 46,
            "Y": 11
          },
          {
            "X": 45,
            "Y": 11
          },
          {
            "X": 44,
            "Y": 11
          },
          {
            "X": 43,
            "Y": 11
          },
          {
            "X": 42,
            "Y": 11
          },
          {
            "X": 41,
            "Y": 11
          },
          {
            "X": 40,
            "Y": 11
          },
          {
            "X": 39,
            "Y": 11
          },
          {
            "X": 38,
            "Y": 11
          }
        ]
      },
      {
        "Type": 0,
        "Points": [
          {
            "X": 28,
            "Y": 15
          },
          {
            "X": 35,
            "Y": 15
          },
          {
            "X": 35,
            "Y": 13
          },
          {
            "X": 37,
            "Y": 13
          }
        ],
        "Cells": [
          {
            "X": 28,
            "Y": 15
          },
          {
            "X": 29,
            "Y": 15
          },
          {
            "X": 30,
            "Y": 15
          },
          {
            "X": 31,
            "Y": 15
          },
          {
            "X": 32,
            "Y": 15
          },
          {
            "X": 33,
            "Y": 15
          },
          {
            "X": 34,
            "Y": 15
          },
          {
            "X": 35,
            "Y": 15
          },
          {
            "X": 35,
            "Y": 14
          },
          {
            "X": 35,
            "Y": 13
          },
          {
            "X": 36,
            "Y": 13
          }
        ]
      },
      {
        "Type": 3,
        "Points": [
          {
            "X": 48,
            "Y": 17
          },
          {
            "X": 48,
            "Y": 20
          },
          {
            "X": 47,
            "Y": 20
          },
          {
            "X": 47,
            "Y": 23
          }
        ],
        "Cells": [
          {
            "X": 48,
            "Y": 17
          },
          {
            "X": 48,
            "Y": 18
          },
          {
            "X": 48,
            "Y": 19
          },
          {
            "X": 48,
            "Y": 20
          },
          {
            "X": 47,
            "Y": 20
          },
          {
            "X": 47,
            "Y": 21
          },
          {
            "X": 47,
            "Y": 22
          }
        ]
      },
      {
        "Type": 3,
        "Points": [
          {
            "X": 70,
            "Y": 17
          },
          {
            "X": 70,
            "Y": 19
          },
          {
            "X": 76,
            "Y": 19
          },
          {
            "X": 76,
            "Y": 21
          }
        ],
        "Cells": [
          {
            "X": 70,
            "Y": 17
          },
          {
            "X": 70,
            "Y": 18
          },
          {
            "X": 70,
            "Y": 19
          },
          {
            "X": 71,
            "Y": 19
          },
          {
            "X": 72,
            "Y": 19
          },
          {
            "X": 73,
            "Y": 19
          },
          {
            "X": 74,
            "Y": 19
          },
          {
            "X": 75,
            "Y": 19
          },
          {
            "X": 76,
            "Y": 19
          },
          {
            "X": 76,
            "Y": 20
          }
        ]
      },
      {
        "Type": 0,
        "Points": [
          {
            "X": 21,
            "Y": 22
          },
          {
            "X": 23,
            "Y": 22
          },
          {
            "X": 23,
            "Y": 25
          },
          {
            "X": 36,
            "Y": 25
          }
        ],
        "Cells": [
          {
            "X": 21,
            "Y": 22
          },
          {
            "X": 22,
            "Y": 22
          },
          {
            "X": 23,
            "Y": 22
          },
          {
            "X": 23,
            "Y": 23
          },
          {
            "X": 23,
            "Y": 24
          },
          {
            "X": 23,
            "Y": 25
          },
          {
            "X": 24,
            "Y": 25
          },
          {
            "X": 25,
            "Y": 25
          },
          {
            "X": 26,
            "Y": 25
          },
          {
            "X": 27,
            "Y": 25
          },
          {
            "X": 28,
            "Y": 25
          },
          {
            "X": 29,
            "Y": 25
          },
          {
            "X": 30,
            "Y": 25
          },
          {
            "X": 31,
            "Y": 25
          },
          {
            "X": 32,
            "Y": 25
          },
          {
            "X": 33,
            "Y": 25
          },
          {
            "X": 34,
            "Y": 25
          },
          {
            "X": 35,
            "Y": 25
          }
        ]
      },
      {
        "Type": 0,
        "Points": [
          {
            "X": 53,
            "Y": 26
          },
          {
            "X": 57,
            "Y": 26
          },
          {
            "X": 57,
            "Y": 22
          },
          {
            "X": 73,
            "Y": 22
          }
        ],
        "Cells": [
          {
            "X": 53,
            "Y": 26
          },
          {
            "X": 54,
            "Y": 26
          },
          {
            "X": 55,
            "Y": 26
          },
          {
            "X": 56,
            "Y": 26
          },
          {
            "X": 57,
            "Y": 26
          },
          {
            "X": 57,
            "Y": 25
          },
          {
            "X": 57,
            "Y": 24
          },
          {
            "X": 57,
            "Y": 23
          },
          {
            "X": 57,
            "Y": 22
          },
          {
            "X": 58,
            "Y": 22
          },
          {
            "X": 59,
            "Y": 22
          },
          {
            "X": 60,
            "Y": 22
          },
          {
            "X": 61,
            "Y": 22
          },
          {
            "X": 62,
            "Y": 22
          },
          {
            "X": 63,
            "Y": 22
          },
          {
            "X": 64,
            "Y": 22
          },
          {
            "X": 65,
            "Y": 22
          },
          {
            "X": 66,
            "Y": 22
          },
          {
            "X": 67,
            "Y": 22
          },
          {
            "X": 68,
            "Y": 22
          },
          {
            "X": 69,
            "Y": 22
          },
          {
            "X": 70,
            "Y": 22
          },
          {
            "X": 71,
            "Y": 22
          },
          {
            "X": 72,
            "Y": 22
          }
        ]
      }
    ],
    "StartPosition": {
      "X": 54,
      "Y": 2
    },
    "ExitPosition": {
      "X": 75,
      "Y": 23
    }
  },
  "Statistics": {
    "TreasuresCollected": 15,
    "MaxLevelReached": 1,
    "EnemiesDefeated": 1,
    "FoodConsumed": 0,
    "ElixirsConsumed": 0,
    "ScrollsConsumed": 0,
    "HitsLanded": 7,
    "HitsMissed": 4,
    "HitsTaken": 9,
    "CellsMoved": 112
  },
  "GameLevel": 1
}


================================================
FILE: src/ProjectTeam01/Program.cs
================================================
﻿using Mindmagma.Curses;
using ProjectTeam01.domain.generation;
using ProjectTeam01.domain.Session;
using ProjectTeam01.presentation.Frontend;
using ProjectTeam01.presentation;
namespace ProjectTeam01
{
    internal class Program
    {
        static readonly nint stdscr = NCurses.InitScreen();
        static void Main(string[] args)
        {
            try
            {
                NCursesMethods.Init(stdscr);
                // Инициализация игры
                InitializeGame();
            }
            finally
            {
                NCursesMethods.Shutdown();
            }
            // Тесты (можно закомментировать для запуска игры)
            // Level(args);
            // Hero hero = new(1, 1);
            // HeroTest(hero);
            // EnemyTest(RandomEnemy());
            //LevelAdvancementTest();
            //JsonTest();
            //StatisticsJsonTest();
        }
        static void InitializeGame()
        {
            // Создаем новую игру через GameInitializer (domain слой)
            var gameSession = GameInitializer.CreateNewGame(levelNumber: 1);
            var controller = new GameController(gameSession);
            bool running = true;
            // Создаем карту
            char[,] map = new char[GenerationConstants.MapHeight, GenerationConstants.MapWidth];
            GameStateRenderer.ActivateColorSystem();
            while (running)
            {
            // Инициализируем карту пробелами
            for (int y = 0; y < GenerationConstants.MapHeight; y++)
            {
                for (int x = 0; x < GenerationConstants.MapWidth; x++)
                {
                    map[y, x] = ' ';
                }
            }  
                var viewModel = controller.GetGameStateViewModel();

                // Отрисовка
                GameStateRenderer.RenderHandler(viewModel, stdscr, controller,map);

                // Получаем ввод
                int key = NCurses.GetChar(); // ждет нажатия клавиши

                // Обработка ввода
                running = controller.HandleInput((char)key);
            }

        }
    //     /// Инициализация и запуск игры
    //     static void InitializeGameStatic()
    //     {
    //         Console.WriteLine("=== ROGUE GAME INITIALIZATION ===");
    //         Console.WriteLine();

    //         // Создаем новую игру через GameInitializer (domain слой)
    //         var gameSession = GameInitializer.CreateNewGame(levelNumber: 1);
    //         var controller = new GameController(gameSession);
    //         var level = gameSession.CurrentLevel;
    //         var hero = gameSession.Player;
            
    //         Console.WriteLine($"Level {level.LevelNumber} generated: {level.Rooms.Count} rooms");
    //         Console.WriteLine($"Player placed at ({hero.Position.X}, {hero.Position.Y})");
    //         Console.WriteLine($"Enemies placed: {level.GetEnemies().Count}");
    //         Console.WriteLine($"Items placed: {level.GetItems().Count}");
    //         Console.WriteLine("Game session created");
    //         Console.WriteLine();

    //         // 4. Получение данных через ViewModels (новый подход)
    //         var viewModel = controller.GetGameStateViewModel();
    //         Console.WriteLine("=== GAME STATE (via ViewModels) ===");
    //         Console.WriteLine($"Player: HP {viewModel.Player.Health}/{viewModel.Player.MaxHealth}, " +
    //                         $"Position ({viewModel.Player.Position.X}, {viewModel.Player.Position.Y})");
    //         Console.WriteLine($"Enemies: {viewModel.Enemies.Count}");
    //         Console.WriteLine($"Items: {viewModel.Items.Count}");
    //         Console.WriteLine($"Exit at: ({viewModel.Level.ExitPosition.X}, {viewModel.Level.ExitPosition.Y})");
    //         Console.WriteLine();
    //         Console.WriteLine("Press Enter to render the level...");
    //         Console.ReadLine();

    //         // 5. Отрисовка уровня с сущностями (через ViewModels)
    //         Console.WriteLine("=== LEVEL RENDERING (via ViewModels) ===");
    //         GameStateRenderer.Render(viewModel,stdscr);
            
    //         Console.WriteLine();
    //         Console.WriteLine("=== GAME STATE DATA (for frontend via ViewModels) ===");
    //         Console.WriteLine($"Level Number: {viewModel.CurrentLevelNumber}");
    //         Console.WriteLine($"Player Position: ({viewModel.Player.Position.X}, {viewModel.Player.Position.Y})");
    //         Console.WriteLine($"Player Stats: HP {viewModel.Player.Health}/{viewModel.Player.MaxHealth}, " +
    //                         $"Strength {viewModel.Player.Strength}, Agility {viewModel.Player.Agility}");
    //         Console.WriteLine($"Enemies Count: {viewModel.Enemies.Count}");
    //         foreach (var enemy in viewModel.Enemies)
    //         {
    //             Console.WriteLine($"  - {enemy.EnemyType} at ({enemy.Position.X}, {enemy.Position.Y}), " +
    //                             $"Dead: {enemy.IsDead}");
    //         }
    //         Console.WriteLine($"Items Count: {viewModel.Items.Count}");
    //         foreach (var item in viewModel.Items)
    //         {
    //             Console.WriteLine($"  - {item.Type} at ({item.Position.X}, {item.Position.Y})");
    //         }
    //         Console.WriteLine();
    //         Console.WriteLine("Game initialized successfully!");
    //         Console.WriteLine("Ready for game loop integration.");

    //         // 6. Сохраняем игру для последующей загрузки в JsonTest
    //         var enemies = level.GetEnemies().ToList();
    //         var items = level.GetItems().ToList();
    //         var statistics = gameSession.Statistics;
            
    //         GameSave save = GameDataService.CreateSave(hero, enemies, items, level, statistics);
    //         string saveFilePath = "game_save.json";
    //         GameDataService.SaveToFile(save, saveFilePath);
    //         Console.WriteLine($"Game saved to {saveFilePath} for testing");

    //         // Чтобы окно консоли не закрывалось сразу при запуске exe двойным кликом
    //         Console.WriteLine();
    //         Console.WriteLine("Press Enter to exit...");
    //         Console.ReadLine();
    //     }



    //     static void Level(string[] args)
    //     {
    //         Console.WriteLine("Dungeon Level Renderer");
    //         Console.WriteLine("=====================");
    //         Console.WriteLine();

    //         RenderExample.GenerateAndRender();
    //     }

    //     /// Тест перехода на следующий уровень с отрисовкой
    //     static void LevelAdvancementTest()
    //     {
    //         Console.WriteLine("=== LEVEL ADVANCEMENT TEST ===");
    //         Console.WriteLine();
    //         Console.WriteLine("Press Enter to start the test...");
    //         Console.ReadLine();

    //         // 1. Создаем игру на уровне 1
    //         var gameSession = GameInitializer.CreateNewGame(levelNumber: 1);
    //         var controller = new GameController(gameSession);
            
    //         Console.WriteLine("=== LEVEL 1 ===");
    //         var viewModel1 = controller.GetGameStateViewModel();
        
    //         GameStateRenderer.Render(viewModel1,stdscr);
    //         Console.WriteLine();
    //         Console.WriteLine("Press Enter to advance to Level 2...");
    //         Console.ReadLine();
    //         // 2. Создаем новый уровень и переходим на него
    //         var levelGenerator = new LevelGenerator();
    //         var nextLevel = levelGenerator.GenerateLevel();
            
    //         int oldLevelNumber = gameSession.CurrentLevelNumber;
    //         Console.WriteLine($"Current Level Number before advancement: {oldLevelNumber}");
            
    //         gameSession.AdvanceToNextLevel(nextLevel);
            
    //         int newLevelNumber = gameSession.CurrentLevelNumber;
    //         Console.WriteLine($"Current Level Number after advancement: {newLevelNumber}");
    //         Console.WriteLine();
           
    //         var viewModel2 = controller.GetGameStateViewModel();
           
    //         Console.WriteLine();
    //         GameStateRenderer.Render(viewModel2,stdscr);
    //         Console.WriteLine();
    //          Console.WriteLine("Press Enter to advance to Level 3...");
    //         Console.ReadLine();
    //         var nextLevel3 = levelGenerator.GenerateLevel();
            
    //         int oldLevelNumber3 = gameSession.CurrentLevelNumber;
    //         Console.WriteLine($"Current Level Number before advancement: {oldLevelNumber3}");
            
    //         gameSession.AdvanceToNextLevel(nextLevel3);
            
    //         int newLevelNumber3 = gameSession.CurrentLevelNumber;
    //         Console.WriteLine($"Current Level Number after advancement: {newLevelNumber3}");
    //         Console.WriteLine();

    //         var viewModel3 = controller.GetGameStateViewModel();
            
    //         GameStateRenderer.Render(viewModel3,stdscr);
    //         Console.WriteLine();
    //         Console.WriteLine("=== TEST COMPLETED ===");
    //         Console.WriteLine();

    //     }

    //     static void JsonTest()
    //     {
    //         Console.WriteLine("=== JSON SAVE/LOAD TEST ===");
    //         Console.WriteLine();
    //         Console.WriteLine("Loading game saved in InitializeGame()...");
    //         Console.WriteLine();

    //         // Загружаем игру, сохраненную в InitializeGame()
    //         string filePath = "game_save.json";
            
    //         if (!File.Exists(filePath))
    //         {
    //             Console.WriteLine($"ERROR: Save file {filePath} not found!");
    //             Console.WriteLine("Make sure InitializeGame() was called first.");
    //             return;
    //         }

    //         // Загружаем игру через GameDataService (получаем GameSession)
    //         var gameSession = GameDataService.LoadGame(filePath);
    //         var controller = new GameController(gameSession);
    //         Console.WriteLine("Game loaded successfully!");
    //         Console.WriteLine();

    //         // Получаем ViewModel для проверки
    //         var viewModel = controller.GetGameStateViewModel();
            
    //         // Проверяем восстановленные данные через ViewModel
    //         Console.WriteLine("=== LOADED GAME DATA ===");
    //         Console.WriteLine($"Hero Position: ({viewModel.Player.Position.X}, {viewModel.Player.Position.Y})");
    //         Console.WriteLine($"Hero HP: {viewModel.Player.Health}/{viewModel.Player.MaxHealth}");
    //         Console.WriteLine($"Enemies count: {viewModel.Enemies.Count}");
    //         Console.WriteLine($"Items count: {viewModel.Items.Count}");
    //         Console.WriteLine($"Level Number: {viewModel.CurrentLevelNumber}");
    //         Console.WriteLine($"Rooms count: {viewModel.Level.Rooms.Count}");
    //         Console.WriteLine($"Corridors count: {viewModel.Level.Corridors.Count}");
    //         Console.WriteLine($"Start Position: ({viewModel.Level.StartPosition.X}, {viewModel.Level.StartPosition.Y})");
    //         Console.WriteLine($"Exit Position: ({viewModel.Level.ExitPosition.X}, {viewModel.Level.ExitPosition.Y})");
    //         Console.WriteLine($"Statistics - Treasures: {controller.GetStatistics().TreasuresCollected}, Enemies Defeated: {controller.GetStatistics().EnemiesDefeated}");
    //         Console.WriteLine();

    //         // Проверяем через ViewModel (как в InitializeGame)
            
    //         Console.WriteLine("=== VERIFICATION VIA VIEWMODEL ===");
    //         Console.WriteLine($"Level Number: {viewModel.CurrentLevelNumber}");
    //         Console.WriteLine($"Player Position: ({viewModel.Player.Position.X}, {viewModel.Player.Position.Y})");
    //         Console.WriteLine($"Player Stats: HP {viewModel.Player.Health}/{viewModel.Player.MaxHealth}, " +
    //                         $"Strength {viewModel.Player.Strength}, Agility {viewModel.Player.Agility}");
    //         Console.WriteLine($"Enemies Count: {viewModel.Enemies.Count}");
    //         foreach (var enemy in viewModel.Enemies)
    //         {
    //             Console.WriteLine($"  - {enemy.EnemyType} at ({enemy.Position.X}, {enemy.Position.Y}), " +
    //                             $"Dead: {enemy.IsDead}");
    //         }
    //         Console.WriteLine($"Items Count: {viewModel.Items.Count}");
    //         foreach (var item in viewModel.Items)
    //         {
    //             Console.WriteLine($"  - {item.Type} at ({item.Position.X}, {item.Position.Y})");
    //         }
    //         Console.WriteLine();
    //         Console.WriteLine("Save/Load test completed successfully!");
    //     }

    //     /// Тест сохранения и загрузки статистики через JSON
    //     static void StatisticsJsonTest()
    //     {
    //         Console.WriteLine("=== STATISTICS JSON SAVE/LOAD TEST ===");
    //         Console.WriteLine();

    //         // 1. Создаем новую статистику и заполняем её данными
    //         var statistics = new GameStatistics(startLevel: 5);
    //         statistics.RecordTreasureCollected(100);
    //         statistics.RecordTreasureCollected(50);
    //         statistics.RecordLevelReached(7);
    //         statistics.RecordEnemyDefeated();
    //         statistics.RecordEnemyDefeated();
    //         statistics.RecordEnemyDefeated();
    //         statistics.RecordFoodConsumed();
    //         statistics.RecordFoodConsumed();
    //         statistics.RecordElixirConsumed();
    //         statistics.RecordScrollConsumed();
    //         statistics.RecordScrollConsumed();
    //         statistics.RecordScrollConsumed();
    //         statistics.RecordPlayerHitAttempt(hit: true);
    //         statistics.RecordPlayerHitAttempt(hit: true);
    //         statistics.RecordPlayerHitAttempt(hit: false);
    //         statistics.RecordHitTaken();
    //         statistics.RecordMove(10);
    //         statistics.RecordMove(5);

    //         Console.WriteLine("=== ORIGINAL STATISTICS ===");
    //         PrintStatistics(statistics);
    //         Console.WriteLine();

    //         // 2. Сохраняем статистику в JSON (создаем минимальный GameSave только со статистикой)
    //         var statisticsSave = GameStatisticsMapper.ToSave(statistics);
    //         var save = new GameSave
    //         {
    //             Statistics = statisticsSave,
    //             Hero = null!, // Для теста не нужны
    //             Enemies = new List<EnemySave>(),
    //             Items = new List<ItemSave>(),
    //             Level = null!, // Для теста не нужны
    //             GameLevel = statistics.MaxLevelReached
    //         };
            
    //         string testFilePath = "test_statistics.json";
    //         GameDataService.SaveToFile(save, testFilePath);
    //         Console.WriteLine($"Statistics saved to {testFilePath}");
    //         Console.WriteLine();

    //         // 3. Загружаем статистику обратно (используем прямой десериализацию для теста)
    //         string jsonString = File.ReadAllText(testFilePath);
    //         var loadedSave = System.Text.Json.JsonSerializer.Deserialize<GameSave>(jsonString) 
    //             ?? throw new Exception("Failed to deserialize test save.");
    //         var loadedStatistics = GameStatisticsMapper.FromSave(loadedSave.Statistics);
            
    //         Console.WriteLine("=== LOADED STATISTICS ===");
    //         PrintStatistics(loadedStatistics);
    //         Console.WriteLine();

    //         // 4. Проверяем, что все данные совпадают
    //         Console.WriteLine("=== VERIFICATION ===");
    //         bool allMatch = true;
            
    //         allMatch &= Verify("TreasuresCollected", statistics.TreasuresCollected, loadedStatistics.TreasuresCollected);
    //         allMatch &= Verify("MaxLevelReached", statistics.MaxLevelReached, loadedStatistics.MaxLevelReached);
    //         allMatch &= Verify("EnemiesDefeated", statistics.EnemiesDefeated, loadedStatistics.EnemiesDefeated);
    //         allMatch &= Verify("FoodConsumed", statistics.FoodConsumed, loadedStatistics.FoodConsumed);
    //         allMatch &= Verify("ElixirsConsumed", statistics.ElixirsConsumed, loadedStatistics.ElixirsConsumed);
    //         allMatch &= Verify("ScrollsConsumed", statistics.ScrollsConsumed, loadedStatistics.ScrollsConsumed);
    //         allMatch &= Verify("HitsLanded", statistics.HitsLanded, loadedStatistics.HitsLanded);
    //         allMatch &= Verify("HitsMissed", statistics.HitsMissed, loadedStatistics.HitsMissed);
    //         allMatch &= Verify("HitsTaken", statistics.HitsTaken, loadedStatistics.HitsTaken);
    //         allMatch &= Verify("CellsMoved", statistics.CellsMoved, loadedStatistics.CellsMoved);

    //         Console.WriteLine();
    //         if (allMatch)
    //         {
    //             Console.WriteLine("✅ ALL STATISTICS MATCH! Test PASSED!");
    //         }
    //         else
    //         {
    //             Console.WriteLine("❌ SOME STATISTICS DON'T MATCH! Test FAILED!");
    //         }
    //         Console.WriteLine();

    //         // Удаляем тестовый файл
    //         if (File.Exists(testFilePath))
    //         {
    //             File.Delete(testFilePath);
    //             Console.WriteLine($"Test file {testFilePath} deleted.");
    //         }
    //     }

    //     static void PrintStatistics(GameStatistics stats)
    //     {
    //         Console.WriteLine($"TreasuresCollected: {stats.TreasuresCollected}");
    //         Console.WriteLine($"MaxLevelReached: {stats.MaxLevelReached}");
    //         Console.WriteLine($"EnemiesDefeated: {stats.EnemiesDefeated}");
    //         Console.WriteLine($"FoodConsumed: {stats.FoodConsumed}");
    //         Console.WriteLine($"ElixirsConsumed: {stats.ElixirsConsumed}");
    //         Console.WriteLine($"ScrollsConsumed: {stats.ScrollsConsumed}");
    //         Console.WriteLine($"HitsLanded: {stats.HitsLanded}");
    //         Console.WriteLine($"HitsMissed: {stats.HitsMissed}");
    //         Console.WriteLine($"HitsTaken: {stats.HitsTaken}");
    //         Console.WriteLine($"CellsMoved: {stats.CellsMoved}");
    //     }

    //     static bool Verify(string fieldName, int expected, int actual)
    //     {
    //         bool match = expected == actual;
    //         string status = match ? "✅" : "❌";
    //         Console.WriteLine($"{status} {fieldName}: expected {expected}, got {actual}");
    //         return match;
    //     }

    }
}



================================================
FILE: src/ProjectTeam01/ProjectTeam01.csproj
================================================
﻿<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <LangVersion>12.0</LangVersion>  
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

  <!--
    ВАЖНО:
    В проекте лежат другие csproj (domain/app/unit_tests). Их obj/bin содержат auto-generated *.cs
    (AssemblyInfo/AssemblyAttributes). Если они попадают в Compile-элементы этого проекта,
    C# компилятор получает дубликаты assembly-атрибутов (CS0579).
    Явно исключаем любые **/obj/** и **/bin/** из компиляции.
  -->
  <ItemGroup>
    <Compile Remove="**\obj\**\*.cs" />
    <Compile Remove="**\bin\**\*.cs" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="dotnet-curses" Version="2.0.0" />
    <PackageReference Include="xunit" Version="2.9.3" />
  </ItemGroup>

</Project>



================================================
FILE: src/ProjectTeam01/ProjectTeam01.sln
================================================
﻿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.14.36705.20 d17.14
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "ProjectTeam01", "ProjectTeam01.csproj", "{9A63A1CF-5477-4DCC-9DA5-9F9232F5DC92}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{9A63A1CF-5477-4DCC-9DA5-9F9232F5DC92}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{9A63A1CF-5477-4DCC-9DA5-9F9232F5DC92}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{9A63A1CF-5477-4DCC-9DA5-9F9232F5DC92}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{9A63A1CF-5477-4DCC-9DA5-9F9232F5DC92}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {455248F8-02D8-4BA3-9C10-59BF43C88E9E}
	EndGlobalSection
EndGlobal



================================================
FILE: src/ProjectTeam01/run_output.txt
================================================
[Empty file]


================================================
FILE: src/ProjectTeam01/scoreboard.json
================================================
{
  "SessionStats": [
    {
      "TreasuresCollected": 22,
      "MaxLevelReached": 1,
      "EnemiesDefeated": 1,
      "FoodConsumed": 0,
      "ElixirsConsumed": 0,
      "ScrollsConsumed": 0,
      "HitsLanded": 8,
      "HitsMissed": 9,
      "HitsTaken": 39,
      "CellsMoved": 273
    },
    {
      "TreasuresCollected": 0,
      "MaxLevelReached": 3,
      "EnemiesDefeated": 0,
      "FoodConsumed": 0,
      "ElixirsConsumed": 0,
      "ScrollsConsumed": 0,
      "HitsLanded": 3,
      "HitsMissed": 1,
      "HitsTaken": 69,
      "CellsMoved": 323
    },
    {
      "TreasuresCollected": 0,
      "MaxLevelReached": 1,
      "EnemiesDefeated": 0,
      "FoodConsumed": 0,
      "ElixirsConsumed": 0,
      "ScrollsConsumed": 0,
      "HitsLanded": 6,
      "HitsMissed": 12,
      "HitsTaken": 13,
      "CellsMoved": 31
    },
    {
      "TreasuresCollected": 0,
      "MaxLevelReached": 1,
      "EnemiesDefeated": 0,
      "FoodConsumed": 0,
      "ElixirsConsumed": 0,
      "ScrollsConsumed": 0,
      "HitsLanded": 8,
      "HitsMissed": 6,
      "HitsTaken": 19,
      "CellsMoved": 197
    },
    {
      "TreasuresCollected": 0,
      "MaxLevelReached": 1,
      "EnemiesDefeated": 0,
      "FoodConsumed": 0,
      "ElixirsConsumed": 0,
      "ScrollsConsumed": 0,
      "HitsLanded": 7,
      "HitsMissed": 4,
      "HitsTaken": 21,
      "CellsMoved": 67
    },
    {
      "TreasuresCollected": 16,
      "MaxLevelReached": 1,
      "EnemiesDefeated": 1,
      "FoodConsumed": 0,
      "ElixirsConsumed": 0,
      "ScrollsConsumed": 0,
      "HitsLanded": 21,
      "HitsMissed": 14,
      "HitsTaken": 29,
      "CellsMoved": 93
    }
  ]
}


================================================
FILE: src/ProjectTeam01/app/ProjectTeam01.app.csproj
================================================
[Empty file]


================================================
FILE: src/ProjectTeam01/app/.gitkeep
================================================
[Empty file]


================================================
FILE: src/ProjectTeam01/datalayer/GameDataService.cs
================================================
﻿using ProjectTeam01.datalayer.Mappers;
using ProjectTeam01.datalayer.Models;
using ProjectTeam01.domain;
using ProjectTeam01.domain.Characters;
using ProjectTeam01.domain.Items;
using ProjectTeam01.domain.generation;
using ProjectTeam01.domain.Session;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace ProjectTeam01.datalayer
{
    /// Сервис для работы с сохранением и загрузкой игровых данных.
    /// Отвечает за сериализацию/десериализацию игрового состояния в JSON.
    internal class GameDataService
    {
        public static GameSave CreateSave(Hero hero, List<Enemy> enemies, List<Item> items, Level level, GameStatistics statistics)
        {
            var save = new GameSave
            {
                Hero = HeroMapper.ToSave(hero),
                Enemies = enemies.Select(e => EnemyMapper.ToSave(e)).ToList(),
                Items = items.Select(i => ItemMapper.ToSave(i)).ToList(),
                Level = LevelMapper.ToSave(level),
                Statistics = GameStatisticsMapper.ToSave(statistics),
                GameLevel = level.LevelNumber
            };
            return save;
        }

        /// Сохранить GameSave в JSON файл
        public static void SaveToFile(GameSave save, string filePath)
        {
            var options = new JsonSerializerOptions
            {
                WriteIndented = true,
                DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
            };
            string jsonString = JsonSerializer.Serialize(save, options);
            File.WriteAllText(filePath, jsonString);
        }

        /// Загрузить GameSave из JSON файла (внутренний метод)
        private static void LoadFromFile(string filePath, out GameSave save)
        {
            string jsonString = File.ReadAllText(filePath);
            save = JsonSerializer.Deserialize<GameSave>(jsonString) ?? throw new Exception("Failed to deserialize game save.");
        }

        /// Загрузить игру из файла и восстановить все объекты (низкоуровневый метод).
        internal static void LoadSave(string filePath, out Hero hero, out List<Enemy> enemies, out List<Item> items, out Level level, out GameStatistics statistics)
        {
            LoadFromFile(filePath, out GameSave gameSave);
            hero = HeroMapper.FromSave(gameSave.Hero);
            enemies = gameSave.Enemies.Select(es => EnemyMapper.FromSave(es)).ToList();
            items = gameSave.Items.Select(isave => ItemMapper.FromSave(isave)).ToList();
            level = LevelMapper.FromSave(gameSave.Level);
            statistics = GameStatisticsMapper.FromSave(gameSave.Statistics);
        }

        /// Загрузить игру из файла и вернуть GameSession.
        /// Восстанавливает все данные (герой, враги, предметы, уровень, статистика).
        public static GameSession LoadGame(string filePath)
        {
            // Загружаем данные
            Hero hero;
            List<Enemy> enemies;
            List<Item> items;
            Level level;
            GameStatistics statistics;

            LoadSave(filePath, out hero, out enemies, out items, out level, out statistics);

            // Добавляем сущности на уровень
            level.AddEntity(hero);
            foreach (var enemy in enemies)
            {
                level.AddEntity(enemy);
            }
            foreach (var item in items)
            {
                level.AddEntity(item);
            }

            // Создаем и возвращаем GameSession с загруженной статистикой
            return new GameSession(level, hero, level.LevelNumber, statistics);
        }

        // ========== РАБОТА СО СТАТИСТИКОЙ И ТАБЛИЦЕЙ ЛИДЕРОВ ==========

        /// Добавить попытку прохождения в таблицу лидеров (вызывается при смерти/победе)
        public static void AddAttemptToScoreboard(GameStatistics statistics, string scoreboardPath)
        {
            // Загружаем существующую таблицу лидеров или создаем новую
            ScoreboardSave scoreboard;
            if (File.Exists(scoreboardPath))
            {
                string jsonString = File.ReadAllText(scoreboardPath);
                scoreboard = JsonSerializer.Deserialize<ScoreboardSave>(jsonString) ?? new ScoreboardSave();
            }
            else
            {
                scoreboard = new ScoreboardSave();
            }

            // Добавляем новую попытку
            var attemptSave = GameStatisticsMapper.ToSave(statistics);
            scoreboard.SessionStats.Add(attemptSave);

            // Сохраняем обновленную таблицу
            var options = new JsonSerializerOptions
            {
                WriteIndented = true,
                DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
            };
            string updatedJson = JsonSerializer.Serialize(scoreboard, options);
            File.WriteAllText(scoreboardPath, updatedJson);
        }

        /// Загрузить таблицу лидеров из файла
        public static ScoreboardSave LoadScoreboard(string scoreboardPath)
        {
            if (!File.Exists(scoreboardPath))
            {
                return new ScoreboardSave();
            }

            string jsonString = File.ReadAllText(scoreboardPath);
            return JsonSerializer.Deserialize<ScoreboardSave>(jsonString) ?? new ScoreboardSave();
        }

        /// Получить лучшие попытки прохождения, отсортированные по количеству сокровищ
        public static List<GameStatisticsSave> GetTopAttempts(string scoreboardPath, int count = 0)
        {
            var scoreboard = LoadScoreboard(scoreboardPath);
            
            // Сортируем по количеству сокровищ (по убыванию)
            var sorted = scoreboard.SessionStats
                .OrderByDescending(s => s.TreasuresCollected)
                .ToList();

            // Возвращаем топ N или все, если count <= 0
            if (count > 0 && count < sorted.Count)
            {
                return sorted.Take(count).ToList();
            }

            return sorted;
        }
    }
}



================================================
FILE: src/ProjectTeam01/datalayer/.gitkeep
================================================
[Empty file]


================================================
FILE: src/ProjectTeam01/datalayer/Mappers/ActiveEffectMapper.cs
================================================
﻿using ProjectTeam01.datalayer.Models;
using ProjectTeam01.domain.Effects;

namespace ProjectTeam01.datalayer.Mappers
{
    internal class ActiveEffectMapper
    {
        public static ActiveEffectSave ToSave(ActiveEffect effect)
        {
            return new ActiveEffectSave
            {
                Type = effect.Type,
                RemainingTicks = effect.RemainingTicks,
                Value = effect.Value
            };
        }

        public static ActiveEffect FromSave(ActiveEffectSave save)
        {
            // Всегда используем сохраненное значение, так как оно всегда сохраняется в ToSave
            return new ActiveEffect(save.Type, save.Value, save.RemainingTicks);
        }
    }
}



================================================
FILE: src/ProjectTeam01/datalayer/Mappers/CorridorMapper.cs
================================================
using System.Linq;
using ProjectTeam01.datalayer.Models;
using ProjectTeam01.domain.generation;

namespace ProjectTeam01.datalayer.Mappers;

internal static class CorridorMapper
{
    public static CorridorSave ToSave(Corridor corridor)
    {
        return new CorridorSave
        {
            Type = corridor.Type,
            Points = corridor.Points.Select(PositionMapper.ToSave).ToList(),
            Cells = corridor.Cells.Select(PositionMapper.ToSave).ToList()
        };
    }

    public static Corridor FromSave(CorridorSave save)
    {
        return new Corridor
        {
            Type = save.Type,
            Points = save.Points.Select(PositionMapper.FromSave).ToList(),
            Cells = save.Cells.Select(PositionMapper.FromSave).ToList()
        };
    }
}




================================================
FILE: src/ProjectTeam01/datalayer/Mappers/EnemyMapper.cs
================================================
﻿using ProjectTeam01.datalayer.Models;
using ProjectTeam01.domain.Characters;

namespace ProjectTeam01.datalayer.Mappers
{
    internal class EnemyMapper
    {
        public static EnemySave ToSave(Enemy enemy)
        {
            EnemySave enemySave = new()
            {
                EnemyType = enemy.EnemyType,
                PosX = enemy.Position.X,
                PosY = enemy.Position.Y,
                ActualHp = enemy.ActualHp,
                IsTriggered = enemy.IsTriggered
            };
            if (enemy is Ogre ogre)
            {
                enemySave.OgreCooldown = ogre.OgreCooldown;
            }
            else if (enemy is Ghost ghost)
            {
                enemySave.IsInvisible = ghost.IsInvisible;
            }
            else if (enemy is Vampire vampire)
            {
                enemySave.EvadedFirstAttack = vampire.EvadedFirstAttack;
            }
            else if (enemy is Mimic mimic)
            {
                enemySave.Representation = mimic.Representation;
            }
            return enemySave;
        }

        public static Enemy FromSave(EnemySave enemySave)
        {
            switch (enemySave.EnemyType)
            {
                case EnemyTypeEnum.Zombie:
                    {
                        Zombie zombie = new Zombie(enemySave.PosX, enemySave.PosY, enemySave.ActualHp)
                        {
                            IsTriggered = enemySave.IsTriggered
                        };
                        return zombie;
                    }
                case EnemyTypeEnum.Vampire:
                    {
                        Vampire vampire = new Vampire(enemySave.PosX, enemySave.PosY, enemySave.ActualHp)
                        {
                            IsTriggered = enemySave.IsTriggered,
                            EvadedFirstAttack = enemySave.EvadedFirstAttack ?? false
                        };
                        return vampire;
                    }
                case EnemyTypeEnum.Ghost:
                    {
                        Ghost ghost = new Ghost(enemySave.PosX, enemySave.PosY, enemySave.ActualHp)
                        {
                            IsTriggered = enemySave.IsTriggered,
                            IsInvisible = enemySave.IsInvisible ?? false
                        };
                        return ghost;
                    }
                case EnemyTypeEnum.Ogre:
                    {
                        Ogre ogre = new Ogre(enemySave.PosX, enemySave.PosY, enemySave.ActualHp)
                        {
                            IsTriggered = enemySave.IsTriggered,
                            OgreCooldown = enemySave.OgreCooldown ?? false
                        };
                        return ogre;
                    }
                case EnemyTypeEnum.Snake:
                    {
                        Snake snake = new Snake(enemySave.PosX, enemySave.PosY, enemySave.ActualHp)
                        {
                            IsTriggered = enemySave.IsTriggered
                        };
                        return snake;
                    }
                case EnemyTypeEnum.Mimic:
                    {
                        Mimic mimic = new Mimic(enemySave.PosX, enemySave.PosY, enemySave.ActualHp)
                        {
                            IsTriggered = enemySave.IsTriggered,
                            Representation = enemySave.Representation ?? MimicsRepresentation.Mimic
                        };
                        return mimic;
                    }
                default:
                    {
                        throw new ArgumentOutOfRangeException(nameof(enemySave.EnemyType),
                        $"Unknown enemy type: {enemySave.EnemyType}");
                    }
            }
        }
    }
}



================================================
FILE: src/ProjectTeam01/datalayer/Mappers/GameStatisticsMapper.cs
================================================
using ProjectTeam01.datalayer.Models;
using ProjectTeam01.domain;
using ProjectTeam01.domain.Session;

namespace ProjectTeam01.datalayer.Mappers;

internal static class GameStatisticsMapper
{
    public static GameStatisticsSave ToSave(GameStatistics statistics)
    {
        return new GameStatisticsSave
        {
            TreasuresCollected = statistics.TreasuresCollected,
            MaxLevelReached = statistics.MaxLevelReached,
            EnemiesDefeated = statistics.EnemiesDefeated,
            FoodConsumed = statistics.FoodConsumed,
            ElixirsConsumed = statistics.ElixirsConsumed,
            ScrollsConsumed = statistics.ScrollsConsumed,
            HitsLanded = statistics.HitsLanded,
            HitsMissed = statistics.HitsMissed,
            HitsTaken = statistics.HitsTaken,
            CellsMoved = statistics.CellsMoved
        };
    }

    public static GameStatistics FromSave(GameStatisticsSave save)
    {
        var statistics = new GameStatistics(save.MaxLevelReached);
        statistics.RestoreFrom(
            save.TreasuresCollected,
            save.MaxLevelReached,
            save.EnemiesDefeated,
            save.FoodConsumed,
            save.ElixirsConsumed,
            save.ScrollsConsumed,
            save.HitsLanded,
            save.HitsMissed,
            save.HitsTaken,
            save.CellsMoved
        );
        return statistics;
    }
}




================================================
FILE: src/ProjectTeam01/datalayer/Mappers/HeroMapper.cs
================================================
﻿using ProjectTeam01.datalayer.Models;
using ProjectTeam01.domain.Characters;
using ProjectTeam01.domain.Items;

namespace ProjectTeam01.datalayer.Mappers
{
    internal class HeroMapper
    {
        public static HeroSave ToSave(Hero hero)
        {
            HeroSave heroSave = new HeroSave
            {
                PosX = hero.Position.X,
                PosY = hero.Position.Y,
                CurrentHp = hero.ActualHp,
                BaseStrength = hero.BaseStrength,
                BaseAgility = hero.BaseAgility,
                BaseMaxHp = hero.BaseMaxHp,
                IsHeroSleep = hero.IsHeroSleep
            };

            foreach (var effect in hero.ActiveEffectManager.ActiveEffects)
            {
                heroSave.ActiveEffects.Add(ActiveEffectMapper.ToSave(effect));
            }

            heroSave.EquippedWeapon = hero.WeaponManager.EquippedWeapon != null
                ? ItemMapper.ToSave(hero.WeaponManager.EquippedWeapon)
                : null;

            foreach (var item in hero.HeroBackpack.AllItems)
            {
                heroSave.HeroBackpack.Add(ItemMapper.ToSave(item));
            }
            return heroSave;
        }

        public static Hero FromSave(HeroSave heroSave)
        {
            Hero hero = new Hero(
                heroSave.PosX,
                heroSave.PosY,
                heroSave.BaseMaxHp,
                heroSave.BaseStrength,
                heroSave.BaseAgility,
                heroSave.CurrentHp,
                heroSave.IsHeroSleep
            );

            foreach (var itemSave in heroSave.HeroBackpack)
            {
                var item = ItemMapper.FromSave(itemSave);
                hero.HeroBackpack.Add(item);
            }

            if (heroSave.EquippedWeapon != null)
            {
                if (ItemMapper.FromSave(heroSave.EquippedWeapon) is Weapon weapon)
                {
                    hero.WeaponManager.EquipWeapon(weapon);
                }
            }

            foreach (var effectSave in heroSave.ActiveEffects)
            {
                var effect = ActiveEffectMapper.FromSave(effectSave);
                hero.ActiveEffectManager.AddActiveEffect(effect);
            }



            return hero;
        }
    }
}



================================================
FILE: src/ProjectTeam01/datalayer/Mappers/ItemMapper.cs
================================================
﻿using ProjectTeam01.datalayer.Models;
using ProjectTeam01.domain.Items;

namespace ProjectTeam01.datalayer.Mappers
{
    internal class ItemMapper
    {
        public static ItemSave ToSave(Item item)
        {
            ItemSave save = new()
            {
                Type = item.Type,
                PosX = item.Position.X,
                PosY = item.Position.Y
            };

            switch (item)
            {
                case Food food:
                    save.HealthValue = food.HealthValue;
                    break;
                case Elixir elixir:
                    save.ElixirType = elixir.ElixirType;
                    break;
                case Treasure treasure:
                    save.Price = treasure.Price;
                    break;
                case Weapon weapon:
                    save.WeaponType = weapon.WeaponType;
                    break;
                case Scroll scroll:
                    save.ScrollType = scroll.ScrollType;
                    break;
            }

            return save;
        }
        public static Item FromSave(ItemSave save)
        {
            switch (save.Type)
            {
                case ItemType.Treasure:
                    return new Treasure(save.PosX, save.PosY, save.GameLevel) { Price = save.Price!.Value};
                case ItemType.Food:
                    return new Food(save.HealthValue ?? 10, save.PosX, save.PosY);
                case ItemType.Elixir:
                    return new Elixir(save.ElixirType!.Value, save.PosX, save.PosY);
                case ItemType.Scroll:
                    return new Scroll(save.ScrollType!.Value, save.PosX, save.PosY);
                case ItemType.Weapon:
                    return new Weapon(save.WeaponType!.Value, save.PosX, save.PosY);
                default:
                    throw new ArgumentOutOfRangeException($"Unknown item type: {save.Type}");
            }
        }
    }
}



================================================
FILE: src/ProjectTeam01/datalayer/Mappers/LevelMapper.cs
================================================
using System.Linq;
using ProjectTeam01.datalayer.Models;
using ProjectTeam01.domain.generation;

namespace ProjectTeam01.datalayer.Mappers;

internal static class LevelMapper
{
    public static LevelSave ToSave(Level level)
    {
        return new LevelSave
        {
            LevelNumber = level.LevelNumber,
            Rooms = level.Rooms.Select(RoomMapper.ToSave).ToList(),
            Corridors = level.Corridors.Select(CorridorMapper.ToSave).ToList(),
            StartPosition = PositionMapper.ToSave(level.StartPosition),
            ExitPosition = PositionMapper.ToSave(level.ExitPosition)
        };
    }

    public static Level FromSave(LevelSave save)
    {
        var level = new Level
        {
            LevelNumber = save.LevelNumber,
            StartPosition = PositionMapper.FromSave(save.StartPosition),
            ExitPosition = PositionMapper.FromSave(save.ExitPosition)
        };

        // Восстанавливаем комнаты
        level.Rooms = save.Rooms.Select(RoomMapper.FromSave).ToList();

        // Восстанавливаем коридоры
        level.Corridors = save.Corridors.Select(CorridorMapper.FromSave).ToList();

        return level;
    }
}




================================================
FILE: src/ProjectTeam01/datalayer/Mappers/PositionMapper.cs
================================================
using ProjectTeam01.datalayer.Models;
using ProjectTeam01.domain.generation;

namespace ProjectTeam01.datalayer.Mappers;

internal static class PositionMapper
{
    public static PositionSave ToSave(Position position)
    {
        return new PositionSave
        {
            X = position.X,
            Y = position.Y
        };
    }

    public static Position FromSave(PositionSave save)
    {
        return new Position(save.X, save.Y);
    }
}




================================================
FILE: src/ProjectTeam01/datalayer/Mappers/RoomMapper.cs
================================================
using System.Linq;
using ProjectTeam01.datalayer.Models;
using ProjectTeam01.domain.generation;

namespace ProjectTeam01.datalayer.Mappers;

internal static class RoomMapper
{
    public static RoomSave ToSave(Room room)
    {
        return new RoomSave
        {
            Sector = room.Sector,
            TopLeft = PositionMapper.ToSave(room.TopLeft),
            BottomRight = PositionMapper.ToSave(room.BottomRight),
            Doors = room.Doors.Where(d => d.X != 0 || d.Y != 0)
                .Select(PositionMapper.ToSave)
                .ToList(),
            IsStartRoom = room.IsStartRoom,
            IsEndRoom = room.IsEndRoom
        };
    }

    public static Room FromSave(RoomSave save)
    {
        var room = new Room
        {
            Sector = save.Sector,
            TopLeft = PositionMapper.FromSave(save.TopLeft),
            BottomRight = PositionMapper.FromSave(save.BottomRight),
            IsStartRoom = save.IsStartRoom,
            IsEndRoom = save.IsEndRoom
        };

        // Восстанавливаем двери
        room.Doors = new Position[4];
        for (int i = 0; i < save.Doors.Count && i < 4; i++)
        {
            room.Doors[i] = PositionMapper.FromSave(save.Doors[i]);
        }

        // Connections не сохраняем, так как они будут восстановлены при загрузке уровня
        room.Connections = new Room[4];

        return room;
    }
}




================================================
FILE: src/ProjectTeam01/datalayer/Models/ActiveEffectSave.cs
================================================
﻿using ProjectTeam01.domain.Effects;

namespace ProjectTeam01.datalayer.Models
{
    internal class ActiveEffectSave
    {
        public EffectTypeEnum Type { get; set; }
        public int RemainingTicks { get; set; }
        public int Value { get; set; }
    }
}



================================================
FILE: src/ProjectTeam01/datalayer/Models/CorridorSave.cs
================================================
using ProjectTeam01.domain.generation;

namespace ProjectTeam01.datalayer.Models;

/// Модель сохранения для Corridor
internal class CorridorSave
{
    public CorridorType Type { get; set; }
    public List<PositionSave> Points { get; set; } = new();
    public List<PositionSave> Cells { get; set; } = new();
}




================================================
FILE: src/ProjectTeam01/datalayer/Models/EnemySave.cs
================================================
﻿using ProjectTeam01.domain.Characters;

namespace ProjectTeam01.datalayer.Models
{
    internal class EnemySave
    {
        public EnemyTypeEnum EnemyType { get; set; }
        public int PosX { get; set; }
        public int PosY { get; set; }
        public int ActualHp { get; set; }
        public bool IsTriggered { get; set; }

        //ogre
        public bool? OgreCooldown { get; set; }
        //ghost
        public bool? IsInvisible { get; set; }
        //vampire
        public bool? EvadedFirstAttack { get; set; }
        //mimic
        public MimicsRepresentation? Representation { get; set; }
    }
}



================================================
FILE: src/ProjectTeam01/datalayer/Models/GameSave.cs
================================================
﻿namespace ProjectTeam01.datalayer.Models
{
    internal class GameSave
    {
        public HeroSave Hero { get; set; } = null!;
        public List<EnemySave> Enemies { get; set; } = new();
        public List<ItemSave> Items { get; set; } = new();
        public LevelSave Level { get; set; } = null!;
        public GameStatisticsSave Statistics { get; set; } = null!;
        public int GameLevel { get; set; }
    }
}



================================================
FILE: src/ProjectTeam01/datalayer/Models/GameStatisticsSave.cs
================================================
namespace ProjectTeam01.datalayer.Models;

/// Модель сохранения для GameStatistics
internal class GameStatisticsSave
{
    public int TreasuresCollected { get; set; }
    public int MaxLevelReached { get; set; }
    public int EnemiesDefeated { get; set; }
    public int FoodConsumed { get; set; }
    public int ElixirsConsumed { get; set; }
    public int ScrollsConsumed { get; set; }
    public int HitsLanded { get; set; }
    public int HitsMissed { get; set; }
    public int HitsTaken { get; set; }
    public int CellsMoved { get; set; }
}




================================================
FILE: src/ProjectTeam01/datalayer/Models/HeroSave.cs
================================================
﻿namespace ProjectTeam01.datalayer.Models
{
    internal class HeroSave
    {
        public int PosX { get; set; }
        public int PosY { get; set; }
        public int CurrentHp { get; set; }
        public int BaseMaxHp { get; set; }
        public int BaseStrength { get; set; }
        public int BaseAgility { get; set; }
        public List<ActiveEffectSave> ActiveEffects { get; set; } = new();
        public ItemSave? EquippedWeapon { get; set; }
        public List<ItemSave> HeroBackpack { get; set; } = new();
        public bool IsHeroSleep { get; set; }
    }
}



================================================
FILE: src/ProjectTeam01/datalayer/Models/ItemSave.cs
================================================
﻿using ProjectTeam01.domain.Effects;
using ProjectTeam01.domain.Items;

namespace ProjectTeam01.datalayer.Models
{
    internal class ItemSave
    {
        public ItemType Type { get; set; }
        public int PosX { get; set; }
        public int PosY { get; set; }
        public int GameLevel { get; set; }

        public int? HealthValue { get; set; }
        public EffectTypeEnum? ElixirType { get; set;}
        public ScrollTypeEnum? ScrollType { get; set; }
        public int? Price { get; set; }
        public WeaponTypeEnum? WeaponType { get; set; }

    }

}



================================================
FILE: src/ProjectTeam01/datalayer/Models/LevelSave.cs
================================================
using ProjectTeam01.domain.generation;

namespace ProjectTeam01.datalayer.Models;

/// Модель сохранения для Level (геометрия уровня)
internal class LevelSave
{
    public int LevelNumber { get; set; }
    public List<RoomSave> Rooms { get; set; } = new();
    public List<CorridorSave> Corridors { get; set; } = new();
    public PositionSave StartPosition { get; set; } = new();
    public PositionSave ExitPosition { get; set; } = new();
}




================================================
FILE: src/ProjectTeam01/datalayer/Models/PositionSave.cs
================================================
namespace ProjectTeam01.datalayer.Models;

/// Модель сохранения для Position
internal class PositionSave
{
    public int X { get; set; }
    public int Y { get; set; }
}




================================================
FILE: src/ProjectTeam01/datalayer/Models/RoomSave.cs
================================================
using ProjectTeam01.domain.generation;

namespace ProjectTeam01.datalayer.Models;

/// Модель сохранения для Room
internal class RoomSave
{
    public int Sector { get; set; }
    public PositionSave TopLeft { get; set; } = new();
    public PositionSave BottomRight { get; set; } = new();
    public List<PositionSave> Doors { get; set; } = new();
    public bool IsStartRoom { get; set; }
    public bool IsEndRoom { get; set; }
}




================================================
FILE: src/ProjectTeam01/datalayer/Models/ScoreboardSave.cs
================================================
namespace ProjectTeam01.datalayer.Models;

/// Модель для таблицы лидеров - содержит список всех попыток прохождения
internal class ScoreboardSave
{
    /// Список статистик всех попыток прохождения
    public List<GameStatisticsSave> SessionStats { get; set; } = new();
}




================================================
FILE: src/ProjectTeam01/domain/Backpack.cs
================================================
﻿using ProjectTeam01.domain.Characters;
using ProjectTeam01.domain.Items;
using ProjectTeam01.domain.Items.Interfaces;

namespace ProjectTeam01.domain
{
    // отвечает за логику рюкзака
    internal class Backpack
    {
        private readonly Dictionary<ItemType, List<Item>> _items;
        private const int MaxElementsOfOneType = 9;//максимальное количество предметов одного типа

        public Backpack()
        {
            _items = new Dictionary<ItemType, List<Item>>();
            foreach (ItemType type in Enum.GetValues(typeof(ItemType)))
                _items[type] = new List<Item>();
        }

        // чтобы проходить по всем предметам в рюкзаке вне зависимости от их типа
        public IEnumerable<Item> AllItems
        {
            get
            {
                return _items.SelectMany(kv => kv.Value);
            }
        }

        public IEnumerable<Item> UsableItems
        {
            get
            {
                return _items.SelectMany(kv => kv.Value).Where(item => item is IUsableItem);//список расходуемых предметов
            }
        }

        public bool EquipWeapon(Weapon weapon, Hero hero)
        {
            if (AllItems.Contains(weapon))
            {
                hero.WeaponManager.EquipWeapon(weapon);
                return true;
            }
            return false;
        }


        public bool IsEmpty
        {
            get
            {
                return !AllItems.Any();
            }
        }

        public bool Add(Item item)
        {
            List<Item> list = _items[item.Type];
            if (item is Treasure newTreasure)//проверяем, если клад
            {
                AddTreasure(list, newTreasure);
                return true;
            }

            if (list.Count < MaxElementsOfOneType)
            {
                list.Add(item);
                return true;
            }
            return false;
        }

        public static void AddTreasure(List<Item> list, Treasure newTreasure)
        {
            if (list.Count == 0)
            {
                list.Add(newTreasure);
            }
            else
            {
                if (list[0] is Treasure existingTreasure)
                    existingTreasure.Price += newTreasure.Price;
            }
        }

        public void DeleteItem(Item item)
        {
            List<Item> list = _items[item.Type];
            list.Remove(item);
        }

        public bool UseItem(Item item, Hero hero)
        {
            if (item is not IUsableItem usableItem)
                return false;

            List<Item> list = _items[item.Type];
            if (!list.Contains(item))
                return false;

            usableItem.Use(hero);
            DeleteItem(item);
            return true;
        }

        /// Суммарная стоимость сокровищ в рюкзаке
        public int GetTotalTreasureValue()
        {
            var treasureList = _items[ItemType.Treasure];
            if (treasureList.Count == 0)
                return 0;

            return treasureList[0] is Treasure treasure ? treasure.Price : 0;
        }
    }
}



================================================
FILE: src/ProjectTeam01/domain/GameObject .cs
================================================
﻿using ProjectTeam01.domain.generation;

namespace ProjectTeam01.domain
{
    /// Общий класс для всех игровых объектов
    internal abstract class GameObject : IGameObject
    {
        public Position Position { get; set; }

        protected GameObject(int x, int y)
        {
            Position = new Position(x, y);
        }

        protected GameObject(Position position)
        {
            Position = position;
        }

        public virtual void MoveTo(int x, int y)
        {
            Position = new Position(x, y);
        }

        public virtual void MoveTo(Position position)
        {
            Position = position;
        }
    }
}



================================================
FILE: src/ProjectTeam01/domain/IGameObject.cs
================================================
﻿using ProjectTeam01.domain.generation;

namespace ProjectTeam01.domain
{
    /// Интерфейс для игровых объектов, которые могут находиться на карте
    public interface IGameObject
    {
        Position Position { get; set; }
        void MoveTo(int x, int y);
        void MoveTo(Position position);
    }
}



================================================
FILE: src/ProjectTeam01/domain/PlayerAction.cs
================================================
using ProjectTeam01.domain.Items;

namespace ProjectTeam01.domain;

/// Действие игрока
internal class PlayerAction
{
    public PlayerActionType Type { get; }
    public int TargetX { get; }
    public int TargetY { get; }
    public Item? SelectedItem { get; }

    private PlayerAction(PlayerActionType type, int targetX = 0, int targetY = 0, Item? selectedItem = null)
    {
        Type = type;
        TargetX = targetX;
        TargetY = targetY;
        SelectedItem = selectedItem;
    }

    public static PlayerAction CreateMove(int x, int y) => new(PlayerActionType.Move, x, y);
    public static PlayerAction CreateUseItem(Item item) => new(PlayerActionType.UseItem, selectedItem: item);
    public static PlayerAction CreateEquipWeapon(Weapon weapon) => new(PlayerActionType.EquipWeapon, selectedItem: weapon);
    public static PlayerAction CreateUnequipWeapon() => new(PlayerActionType.UnequipWeapon);
    public static PlayerAction CreateDropItem(Item item) => new(PlayerActionType.DropItem, selectedItem: item);
    public static PlayerAction CreateQuit() => new(PlayerActionType.Quit);
}

/// Тип действия игрока
internal enum PlayerActionType
{
    Move,
    UseItem,
    EquipWeapon,
    UnequipWeapon,
    DropItem,
    Quit
}




================================================
FILE: src/ProjectTeam01/domain/ProjectTeam01.domain.csproj
================================================
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>

</Project>




================================================
FILE: src/ProjectTeam01/domain/.gitkeep
================================================
[Empty file]


================================================
FILE: src/ProjectTeam01/domain/Characters/Enemy.cs
================================================
﻿namespace ProjectTeam01.domain.Characters
{

    public enum EnemyTypeEnum
    {
        Zombie,
        Vampire,
        Ghost,
        Ogre,
        Snake,
        Mimic
    }

    internal class Enemy : Character
    {
        public Enemy(EnemyTypeEnum enemyType, int posX, int posY) : base(posX, posY)
        {
            EnemyType = enemyType;
            IsTriggered = false;
        }

        public Enemy(EnemyTypeEnum enemyType, int posX, int posY, int actualHp) : base(posX, posY)// конструктор для воостановления врага из сохранения
        {
            ActualHp = actualHp;
            EnemyType = enemyType;
            IsTriggered = false;
        }

        private int _actualHp;

        public override int ActualHp
        {
            get
            {
                return _actualHp;
            }
            protected set
            {
                if (value <= 0)
                {
                    _actualHp = 0;
                }
                else
                {
                    _actualHp = value;
                }
            }
        }

        public EnemyTypeEnum EnemyType { get; }
        public bool IsTriggered { get; set; }
        public int HostilityLevel { get; set; }//враждебность 
    }
}



================================================
FILE: src/ProjectTeam01/domain/Characters/Ghost.cs
================================================
﻿namespace ProjectTeam01.domain.Characters
{
    internal class Ghost: Enemy
    {
        public Ghost(int posX, int posY) : base(EnemyTypeEnum.Ghost, posX, posY)
        {
            ActualHp = 100;
            BaseAgility = 3;
            BaseStrength = 1;
            HostilityLevel = 1;
        }

        public Ghost(int posX, int posY, int actualHp) : base(EnemyTypeEnum.Ghost, posX, posY)
        {
            ActualHp = actualHp;
            BaseAgility = 3;
            BaseStrength = 1;
            HostilityLevel = 1;
        }

        public bool IsInvisible { get; set; } = true;

    }
}



================================================
FILE: src/ProjectTeam01/domain/Characters/Hero.cs
================================================
﻿using ProjectTeam01.domain;
using ProjectTeam01.domain.Effects;

namespace ProjectTeam01.domain.Characters
{
    internal class Hero : Character
    {
        private List<ActiveEffect> ActiveEffects { get; set; }
        public ActiveEffectManager ActiveEffectManager { get; }
        public WeaponManager WeaponManager { get; }
        public Backpack HeroBackpack { get; }
        public bool IsHeroSleep { get; protected set; }

        public Hero(int posX, int posY) : base(posX, posY)
        {
            ActiveEffects = new List<ActiveEffect>();
            ActiveEffectManager = new ActiveEffectManager(ActiveEffects, this);
            WeaponManager = new WeaponManager();
            HeroBackpack = new Backpack();
            BaseAgility = 5;
            BaseStrength = 5;
            BaseMaxHp = 150;
            ActualHp = MaxHp;
        }

        //контруктор для воостановления героя из сохранения
        internal Hero(
        int posX,
        int posY,
        int baseMaxHp,
        int baseStrength,
        int baseAgility,
        int currentHp,
        bool isHeroSleep
    ) : base(posX, posY)
        {
            ActiveEffects = new List<ActiveEffect>();
            ActiveEffectManager = new ActiveEffectManager(ActiveEffects, this);
            WeaponManager = new WeaponManager();
            HeroBackpack = new Backpack();

            BaseMaxHp = baseMaxHp;
            BaseStrength = baseStrength;
            BaseAgility = baseAgility;
            ActualHp = currentHp;
            IsHeroSleep = isHeroSleep;

        }
        private int _actualHp;

        public void MaxHpDecrease(int decreaseValue, bool debuffIsAtive)
        {
            if (debuffIsAtive)
            {
                BaseMaxHp -= decreaseValue;
                if (ActualHp > MaxHp)
                {
                    ActualHp = MaxHp;
                }
            }
            else
            {
                BaseMaxHp += decreaseValue;
            }
        }

        public override int ActualHp
        {
            get
            {
                return _actualHp;
            }
            protected set
            {
                if (value >= MaxHp)
                {
                    _actualHp = MaxHp;
                }
                else if (value <= 0)
                {
                    _actualHp = 0;
                }
                else
                {
                    _actualHp = value;
                }
            }
        }

        public int Strength
        {
            get
            {
                int weaponBonus = WeaponManager.GetStrengthBonus();
                int effectBonus = ActiveEffectManager.GetTotalStatBonus(EffectTypeEnum.BuffStrength);
                return BaseStrength + weaponBonus + effectBonus;
            }
        }

        public int Agility
        {
            get
            {
                return BaseAgility + ActiveEffectManager.GetTotalStatBonus(EffectTypeEnum.BuffAgility);

            }
        }

        public int MaxHp
        {
            get
            {
                int buffHp = ActiveEffectManager.GetTotalStatBonus(EffectTypeEnum.BuffMaxHp);
                return BaseMaxHp + buffHp;
            }
        }

        public void ApplySleep()
        {
            IsHeroSleep = true;
        }

        public void WakeUp()
        {
            IsHeroSleep = false;
        }
    }
}



================================================
FILE: src/ProjectTeam01/domain/Characters/Mimic.cs
================================================
﻿namespace ProjectTeam01.domain.Characters
{
    /// <summary>
    /// Представление Mimic для использования в ViewModels
    /// </summary>
    public enum MimicsRepresentation
    {
        Food,
        Elixir,
        Scroll,
        Weapon,
        Mimic
    }

    internal class Mimic : Enemy
    {
        protected static readonly Random random = new();
        public MimicsRepresentation Representation { get; set; }

        public Mimic(int posX, int posY) : base(EnemyTypeEnum.Mimic, posX, posY)
        {
            ActualHp = 175;
            BaseAgility = 3;
            BaseStrength = 1;
            HostilityLevel = 1;
            Representation = RandomRepresentation();
        }

        public Mimic(int posX, int posY, int actualHp) : base(EnemyTypeEnum.Mimic, posX, posY)
        {
            ActualHp = actualHp;
            BaseAgility = 3;
            BaseStrength = 1;
            HostilityLevel = 1;
            Representation = RandomRepresentation();
        }

        private MimicsRepresentation RandomRepresentation()
        {
            MimicsRepresentation mimics = (MimicsRepresentation)random.Next(0, 4);
            return  mimics;
        }
    }
}



================================================
FILE: src/ProjectTeam01/domain/Characters/Ogre.cs
================================================
﻿namespace ProjectTeam01.domain.Characters
{
    internal class Ogre : Enemy
    {
        public Ogre(int posX, int posY) : base(EnemyTypeEnum.Ogre, posX, posY)
        {
            ActualHp = 175;
            BaseAgility = 1;
            BaseStrength = 4;
            HostilityLevel = 2;
        }

        public Ogre(int posX, int posY, int actualHp) : base(EnemyTypeEnum.Ogre, posX, posY)
        {
            ActualHp = actualHp;
            BaseAgility = 1;
            BaseStrength = 4;
            HostilityLevel = 2;
        }

        public bool OgreCooldown { get; set; } = false;
    }
}



================================================
FILE: src/ProjectTeam01/domain/Characters/Snake.cs
================================================
﻿namespace ProjectTeam01.domain.Characters
{
    internal class Snake : Enemy
    {
        public const int SleepChancePercent = 30;

        public Snake(int posX, int posY) : base(EnemyTypeEnum.Snake, posX, posY)
        {
            ActualHp = 100;
            BaseAgility = 4;
            BaseStrength = 1;
            HostilityLevel = 3;
        }

        public Snake(int posX, int posY, int actualHp) : base(EnemyTypeEnum.Snake, posX, posY)
        {
            ActualHp = actualHp;
            BaseAgility = 4;
            BaseStrength = 1;
            HostilityLevel = 3;
        }

    }
}



================================================
FILE: src/ProjectTeam01/domain/Characters/Vampire .cs
================================================
﻿namespace ProjectTeam01.domain.Characters
{
    internal class Vampire : Enemy
    {
        public Vampire(int posX, int posY) : base(EnemyTypeEnum.Vampire, posX, posY)
        {
            ActualHp = 150;
            BaseAgility = 3;
            BaseStrength = 2;
            HostilityLevel = 3;
        }

        public Vampire(int posX, int posY, int actualHp) : base(EnemyTypeEnum.Vampire, posX, posY)// конструктор для воостановления врага из сохранения
        {
            ActualHp = actualHp;
            BaseAgility = 3;
            BaseStrength = 2;
            HostilityLevel = 3;
        }
        
        public bool EvadedFirstAttack { get; set; } = false;
    }
}



================================================
FILE: src/ProjectTeam01/domain/Characters/Zombie.cs
================================================
﻿namespace ProjectTeam01.domain.Characters
{
    internal class Zombie : Enemy
    {
        public Zombie(int posX, int posY) : base(EnemyTypeEnum.Zombie, posX, posY)
        {
            ActualHp = 150;
            BaseAgility = 1;
            BaseStrength = 2;
            HostilityLevel = 2;
        }
        public Zombie(int posX, int posY, int actualHp) : base(EnemyTypeEnum.Zombie, posX, posY)// конструктор для воостановления врага из сохранения
        {
            ActualHp = actualHp;
            BaseAgility = 1;
            BaseStrength = 2;
            HostilityLevel = 2;
        }
    }
}



================================================
FILE: src/ProjectTeam01/domain/Characters/Сharacter.cs
================================================
﻿namespace ProjectTeam01.domain.Characters
{
    internal abstract class Character : GameObject
    {
        protected Character(int posX, int posY) : base(posX, posY) { }

        private int _agility;
        private int _strength;
        private int _baseMaxHp;

        public int BaseMaxHp
        {
            get
            {
                return _baseMaxHp;
            }
            protected set
            {
                if (value < 1)
                    _baseMaxHp = 1;
                else
                    _baseMaxHp = value;
            }
        }

        public int BaseAgility
        {
            get { return _agility; }
            protected set
            {
                if (value < 0)
                    _agility = 0;
                else
                    _agility = value;
            }
        }

        public int BaseStrength
        {
            get { return _strength; }
            protected set
            {
                if (value < 0)
                    _strength = 0;
                else
                    _strength = value;
            }
        }

        public void TakeDamage(int damageValue)
        {
            ActualHp -= damageValue;
        }

        public void ChangeBaseAgility(int value)
        {
            BaseAgility += value;
        }
        public void ChangeBaseStrength(int value)
        {
            BaseStrength += value;
        }

        public void ChangeBaseMaxHp(int value)
        {
            BaseMaxHp += value;
        }

        public void Heal(int healValue)
        {
            ActualHp += healValue;
        }

        abstract public int ActualHp { get; protected set; }
        public bool IsDead { get { return ActualHp <= 0; } }

    }
}



================================================
FILE: src/ProjectTeam01/domain/Characters/Behavior/CharacterBehavior.cs
================================================
﻿using ProjectTeam01.domain.Combat;

namespace ProjectTeam01.domain.Characters.Behavior
{
    internal abstract class CharacterBehavior : ICharacterBehavior
    {
        protected readonly Character Character;

        public CharacterBehavior(Character character)
        {
            Character = character;
        }

        public virtual void TakeDamage(int damageValue)
        {
            Character.TakeDamage(damageValue);
        }

        public bool Attack(Character target)
        {
            if (BattleService.HitSuccess(Character.BaseAgility, target.BaseAgility))
            {
                target.TakeDamage(Character.BaseStrength);
                return true;
            }
            else return false;
        }
    }
}



================================================
FILE: src/ProjectTeam01/domain/Characters/Behavior/EnemyBehavior.cs
================================================
﻿using ProjectTeam01.domain.generation;

namespace ProjectTeam01.domain.Characters.Behavior
{
    internal abstract class EnemyBehavior(Enemy enemy, IMapQuery map) : CharacterBehavior(enemy)
    {
        protected readonly Enemy Enemy = enemy;
        protected readonly IMapQuery Map = map;
        protected static readonly Random random = new();
        protected bool LootDropped { get; set; } = false;

        public abstract void Tick(Hero hero);

        protected virtual void SpecialEffectOnAttack(Hero hero) { }

        protected bool MoveRandom()
        {
            for (int attempts = 0; attempts < 10; attempts++)
            {
                int dx = random.Next(-1, 2);
                int dy = random.Next(-1, 2);
                if (TryMoveTo(Enemy.Position.X + dx, Enemy.Position.Y + dy)) return true;
            }
            return false;
        }

        protected bool MoveTowards(Hero hero)
        {
            int bestX = Enemy.Position.X;
            int bestY = Enemy.Position.Y;
            int bestDist = Map.GetDistance(bestX, bestY, hero.Position.X, hero.Position.Y);

            bool found = false;

            for (int dx = -1; dx <= 1; dx++)
            {
                for (int dy = -1; dy <= 1; dy++)
                {
                    if (dx == 0 && dy == 0) continue;

                    int nx = Enemy.Position.X + dx;
                    int ny = Enemy.Position.Y + dy;

                    if (Map.IsOccupied(nx, ny))
                        continue;

                    int dist = Map.GetDistance(nx, ny, hero.Position.X, hero.Position.Y);
                    if (dist < bestDist)
                    {
                        bestDist = dist;
                        bestX = nx;
                        bestY = ny;
                        found = true;
                    }
                }
            }

            return found && TryMoveTo(bestX, bestY);
        }

        protected int DistanceToHero(Hero hero)
        {
            return Map.GetDistance(Enemy.Position.X, Enemy.Position.Y, hero.Position.X, hero.Position.Y);
        }

        protected bool TryMoveTo(int x, int y)
        {
            if (!Map.IsOccupied(x, y))
            {
                Enemy.MoveTo(x, y);
                return true;
            }
            else
                return false;
        }

        static protected bool Chance(int percent)
        {
            return random.Next(0, 100) < percent;
        }
    }
}



================================================
FILE: src/ProjectTeam01/domain/Characters/Behavior/GhostBehavior.cs
================================================
﻿using ProjectTeam01.domain.generation;

namespace ProjectTeam01.domain.Characters.Behavior
{
    internal class GhostBehavior(Enemy enemy, IMapQuery map) : EnemyBehavior(enemy, map)
    {
        public override void Tick(Hero hero)
        {
            int distanceToHero = DistanceToHero(hero);
            if (distanceToHero <= Enemy.HostilityLevel)
            {
                Enemy.IsTriggered = true;
                if (Enemy is Ghost ghost)
                {
                    ghost.IsInvisible = false;
                }

                if (!MoveTowards(hero))
                    Teleport();
            }
            else
            {
                Teleport();
            }

            if (DistanceToHero(hero) == 1)
                Attack(hero);
        }

        private bool Teleport()
        {
            // Сначала проверяем, в комнате ли призрак
            var room = Map.FindRoomAt(Enemy.Position.X, Enemy.Position.Y);
            if (room != null)
            {
                return TeleportInRoom(room);
            }

            // Если не в комнате, проверяем, в коридоре ли
            var corridor = Map.FindCorridorAt(Enemy.Position.X, Enemy.Position.Y);
            if (corridor != null)
            {
                return TeleportInCorridor(corridor);
            }

            // Если ни в комнате, ни в коридоре - не телепортируемся
            return false;
        }

        private bool TeleportInRoom(Room room)
        {
            const int MAX_TRIES = 10;
            for (int attempt = 0; attempt < MAX_TRIES; attempt++)
            {
                int minX = room.TopLeft.X + 1;
                int maxX = room.BottomRight.X - 1;
                int minY = room.TopLeft.Y + 1;
                int maxY = room.BottomRight.Y - 1;

                if (minX >= maxX) minX = maxX = room.TopLeft.X;
                if (minY >= maxY) minY = maxY = room.TopLeft.Y;

                int targetX = random.Next(minX, maxX + 1);
                int targetY = random.Next(minY, maxY + 1);

                if (TryMoveTo(targetX, targetY))
                    return true;
            }

            return false;
        }

        private bool TeleportInCorridor(Corridor corridor)
        {
            if (corridor.Cells == null || corridor.Cells.Count == 0)
                return false;

            const int MAX_TRIES = 10;
            for (int attempt = 0; attempt < MAX_TRIES; attempt++)
            {
                // Выбираем случайную клетку из коридора
                int randomIndex = random.Next(0, corridor.Cells.Count);
                var targetPos = corridor.Cells[randomIndex];

                if (TryMoveTo(targetPos.X, targetPos.Y))
                    return true;
            }

            return false;
        }
    }
}



================================================
FILE: src/ProjectTeam01/domain/Characters/Behavior/ICharacterBehavior.cs
================================================
﻿namespace ProjectTeam01.domain.Characters.Behavior
{
    internal interface ICharacterBehavior
    {
        public bool Attack(Character character);
        public void TakeDamage(int damageValue);
    }
}



================================================
FILE: src/ProjectTeam01/domain/Characters/Behavior/MimicBehavior.cs
================================================
﻿using ProjectTeam01.domain.generation;

namespace ProjectTeam01.domain.Characters.Behavior
{
    internal class MimicBehavior(Mimic mimic, IMapQuery map) : EnemyBehavior(mimic, map)
    {
        public override void Tick(Hero hero)
        {
            int distanceToHero = DistanceToHero(hero);
            if (distanceToHero <= Enemy.HostilityLevel)
            {
                Enemy.IsTriggered = true;
                mimic.Representation = MimicsRepresentation.Mimic;
                
                if (!MoveTowards(hero))
                    MoveRandom();
            }
            else
            {
                MoveRandom();
            }

            if (DistanceToHero(hero) == 1)
                Attack(hero);
        }
    }
}



================================================
FILE: src/ProjectTeam01/domain/Characters/Behavior/OgreBehavior.cs
================================================
﻿using ProjectTeam01.domain.generation;

namespace ProjectTeam01.domain.Characters.Behavior
{
    internal class OgreBehavior(Ogre ogre, IMapQuery map) : EnemyBehavior(ogre, map)
    {
        public override void Tick(Hero hero)
        {
            int distanceToHero = DistanceToHero(hero);
            if (distanceToHero <= Enemy.HostilityLevel)
            {
                Enemy.IsTriggered = true;

                if (MoveTwice(hero))
                {
                }
                else if (!MoveTowards(hero))
                {
                    MoveRandom();
                }
            }
            else
            {
                MoveRandom();
            }

            if (DistanceToHero(hero) == 1)
            {
                Attack(hero);
            }
        }

        protected bool MoveTwice(Hero hero)
        {
            int dx = hero.Position.X > Enemy.Position.X ? 2 :
                     hero.Position.X < Enemy.Position.X ? -2 : 0;

            int dy = hero.Position.Y > Enemy.Position.Y ? 2 :
                     hero.Position.Y < Enemy.Position.Y ? -2 : 0;

            return TryMoveTo(Enemy.Position.X + dx, Enemy.Position.Y + dy);
        }

        public override void TakeDamage(int damageValue)
        {
            Enemy.TakeDamage(damageValue);
        }

    }
}



================================================
FILE: src/ProjectTeam01/domain/Characters/Behavior/SnakeBehavior.cs
================================================
﻿using ProjectTeam01.domain.Effects;
using ProjectTeam01.domain.generation;

namespace ProjectTeam01.domain.Characters.Behavior
{
    internal class SnakeBehavior(Enemy enemy, IMapQuery map) : EnemyBehavior(enemy, map)
    {
        private int dx = 1;
        private int dy = 1;

        public override void Tick(Hero hero)
        {
            int distanceToHero = DistanceToHero(hero);

            if (distanceToHero <= Enemy.HostilityLevel)
            {
                Enemy.IsTriggered = true;
                if (!MoveTowards(hero))
                    ChangeDirection();
            }
            else
            {
                ChangeDirection();
            }

            if (DistanceToHero(hero) == 1)
            {
                if (Attack(hero)) SpecialEffectOnAttack(hero);
            }
        }

        private void ChangeDirection()
        {
            int attempts = 8;
            while (attempts-- > 0)
            {
                if (Chance(50)) dx *= -1;
                if (Chance(50)) dy *= -1;

                if (TryMoveTo(Enemy.Position.X + dx, Enemy.Position.Y + dy))
                    break;
            }
        }

        protected static void FallHeroToSleep(Hero hero)
        {
            if (hero.IsHeroSleep) return;
            ActiveEffect sleep = new(EffectTypeEnum.Sleep);
            hero.ActiveEffectManager.AddActiveEffect(sleep);
        }

        protected override void SpecialEffectOnAttack(Hero hero)
        {
            if (Chance(Snake.SleepChancePercent))
                FallHeroToSleep(hero);
        }
    }
}



================================================
FILE: src/ProjectTeam01/domain/Characters/Behavior/VampireBehavior.cs
================================================
﻿using ProjectTeam01.domain.generation;

namespace ProjectTeam01.domain.Characters.Behavior
{
    internal class VampireBehavior(Vampire vampire, IMapQuery map) : EnemyBehavior(vampire, map)
    {
        public override void Tick(Hero hero)
        {
            int distanceToHero = DistanceToHero(hero);

            if (distanceToHero <= Enemy.HostilityLevel)
            {
                Enemy.IsTriggered = true;

                if (!MoveTowards(hero))
                    MoveRandom();
            }
            else
            {
                MoveRandom();
            }

            if (DistanceToHero(hero) == 1)
            {
                Attack(hero);
            }
        }

        public override void TakeDamage(int damageValue)
        {
            if (!vampire.EvadedFirstAttack)
                vampire.EvadedFirstAttack = true;
            else Enemy.TakeDamage(damageValue);
        }
    }
}



================================================
FILE: src/ProjectTeam01/domain/Characters/Behavior/ZombieBehavior.cs
================================================
﻿using ProjectTeam01.domain.generation;

namespace ProjectTeam01.domain.Characters.Behavior
{
    internal class ZombieBehavior(Enemy enemy, IMapQuery map) : EnemyBehavior(enemy, map)
    {
        public override void Tick(Hero hero)
        {
            int distanceToHero = DistanceToHero(hero);
            if (distanceToHero <= Enemy.HostilityLevel)
            {
                Enemy.IsTriggered = true;

                if (!MoveTowards(hero))
                    MoveRandom();
            }
            else
            {
                MoveRandom();
            }

            if (DistanceToHero(hero) == 1)
                Attack(hero);
        }

    }
}



================================================
FILE: src/ProjectTeam01/domain/Combat/BattleConstants.cs
================================================
namespace ProjectTeam01.domain.Combat;
/// Константы для боевых формул (из rogue_sample)
internal static class BattleConstants
{
    // Шанс попадания
    public const int InitialHitChance = 70;        // Базовый шанс попадания (%)
    public const int StandardAgility = 50;         // Стандартная ловкость
    public const double AgilityFactor = 0.3;       // Множитель ловкости

    // Урон
    public const int InitialDamage = 30;           // Базовый урон
    public const int StandardStrength = 50;        // Стандартная сила
    public const double StrengthFactor = 0.3;      // Множитель силы
    public const int StrengthAddition = 65;        // Добавка к силе при расчете урона с оружием

    // Лут
    public const double LootAgilityFactor = 0.2;   // Множитель ловкости для лута
    public const double LootHpFactor = 0.5;       // Множитель здоровья для лута
    public const double LootStrengthFactor = 0.5;  // Множитель силы для лута
    public const int LootRandomMax = 20;           // Максимальное случайное значение для лута

    // Вампир
    public const int MaxHpPart = 10;               // Делитель для урона вампира (max_hp / 10)
}




================================================
FILE: src/ProjectTeam01/domain/Combat/BattleService.cs
================================================
namespace ProjectTeam01.domain.Combat;

// Отвечает за логику боя, вероятность удара в зависимости от ловкости
internal class BattleService
{
    /// Проверить, попал ли атакующий по цели
    public static bool HitSuccess(int attackerBaseAgility, int targetBaseAgility, bool alwaysHit = false)
    {
        // Огр всегда попадает
        if (alwaysHit)
            return true;

        double hitChance = BattleConstants.InitialHitChance 
            + (attackerBaseAgility - targetBaseAgility - BattleConstants.StandardAgility) 
            * BattleConstants.AgilityFactor;

        // Ограничиваем шанс пределами (0-100%)
        int hitChanceInt = (int)Math.Round(hitChance);
        if (hitChanceInt < 0) hitChanceInt = 0;
        if (hitChanceInt > 100) hitChanceInt = 100;

        return Random.Shared.Next(0, 100) < hitChanceInt;
    }
}




================================================
FILE: src/ProjectTeam01/domain/Combat/CombatResult.cs
================================================
namespace ProjectTeam01.domain.Combat;

/// Результат боя
internal enum CombatResult
{
    NoCombat,
    Ongoing,
    PlayerDefeated,
    EnemyDefeated
}




================================================
FILE: src/ProjectTeam01/domain/Effects/ActiveEffect.cs
================================================
﻿namespace ProjectTeam01.domain.Effects
{
    public enum EffectTypeEnum
    {
        BuffStrength,
        BuffAgility,
        BuffMaxHp,
        Sleep
    }

    internal class ActiveEffect
    {
        public ActiveEffect(EffectTypeEnum effectType)
        {
            Type = effectType;
            RemainingTicks = DurationVal(effectType);
            Value = ValuesByType(effectType);
        }

        public ActiveEffect(EffectTypeEnum effectType, int value, int durationTicks)
        {
            Type = effectType;
            Value = value;
            RemainingTicks = durationTicks;
        }

        // Конструктор для загрузки сохранений (порядок параметров: effectType, remainingTicks, value)
        public static ActiveEffect FromSave(EffectTypeEnum effectType, int remainingTicks, int value)
        {
            return new ActiveEffect(effectType, value, remainingTicks);
        }

        public EffectTypeEnum Type { get; }

        public int Value { get; }

        public int RemainingTicks { get; private set; }//оставшиеся тики действия эффекта

        public static int DurationVal(EffectTypeEnum effect)
        {
            if (effect == EffectTypeEnum.Sleep)
                return 1;
            else return 5;
        }

        public static int ValuesByType(EffectTypeEnum effect)
        {
            switch (effect)
            {
                case EffectTypeEnum.BuffStrength:
                    return 5;
                case EffectTypeEnum.BuffAgility:
                    return 5;
                case EffectTypeEnum.BuffMaxHp:
                    return 10;
                default:
                    return 0;
            }
        }
        public void Tick()
        {
            if (!IsEffectOver)
            {
                RemainingTicks -= 1;
                if (RemainingTicks <= 0)
                    IsEffectOver = true;
            }
        }
        public bool IsEffectOver { get; private set; }

       
    }
}



================================================
FILE: src/ProjectTeam01/domain/Effects/ActiveEffectManager.cs
================================================
﻿using ProjectTeam01.domain.Characters;

namespace ProjectTeam01.domain.Effects
{
    internal class ActiveEffectManager(List<ActiveEffect> activeEffects, Hero hero)
    {
        public List<ActiveEffect> ActiveEffects { get; } = activeEffects;
        private Hero Hero { get; set; } = hero;

        public void AddActiveEffect(ActiveEffect effect)
        {
            ActiveEffects.Add(effect);
            ApplyStateEffect(effect);
        }

        // для эффектов силы, ловкости, здоровья
        public int ApplyStatEffect(ActiveEffect effect)
        {
            switch (effect.Type)
            {
                case EffectTypeEnum.BuffStrength:
                    return effect.Value; // возвращаем значение эффекта
                case EffectTypeEnum.BuffAgility:
                    return effect.Value;
                case EffectTypeEnum.BuffMaxHp:
                    return effect.Value;
                default:
                    return 0;
            }

        }

        public int GetTotalStatBonus(EffectTypeEnum statType)
        {
            return ActiveEffects
                .Where(e => e.Type == statType)
                .Sum(e => ApplyStatEffect(e)); 
        }
        // для эффектов сна
        private void ApplyStateEffect(ActiveEffect effect)
        {
            switch (effect.Type)
            {
                case EffectTypeEnum.Sleep:
                    Hero.ApplySleep();
                    break;
                default:
                    break;
            }
        }
        private void RemoveStateEffect(ActiveEffect effect)
        {
            switch (effect.Type)
            {
                case EffectTypeEnum.Sleep:
                    Hero.WakeUp(); // пробуждаем героя
                    break;
            }
        }

        public void TickEffects()//обновляем эффекты каждый тик
        {
            int counter = ActiveEffects.Count;
            for (int i = counter - 1; i >= 0; i--)
            {
                ActiveEffect effect = ActiveEffects[i];
                effect.Tick();
                if (effect.IsEffectOver)
                {
                    // Сохраняем тип эффекта для проверки после удаления
                    bool wasBuffMaxHp = effect.Type == EffectTypeEnum.BuffMaxHp;
                    
                    RemoveStateEffect(effect);
                    ActiveEffects.Remove(effect);
                    
                    if (wasBuffMaxHp && Hero.ActualHp <= 0)
                    {
                        Hero.Heal(1 - Hero.ActualHp); // лечим героя на 1 HP
                    }
                }
            }
        }
    }
}



================================================
FILE: src/ProjectTeam01/domain/Effects/WeaponManager.cs
================================================
﻿using ProjectTeam01.domain.Items;

namespace ProjectTeam01.domain.Effects
{
    internal class WeaponManager
    {
        public Weapon? EquippedWeapon { get; private set; }

        public Weapon? EquipWeapon(Weapon weapon)
        {
            Weapon? previousWeapon = EquippedWeapon;
            UnequipWeapon();
            EquippedWeapon = weapon;
            return previousWeapon;
        }

        public Weapon? UnequipWeapon()
        {
            Weapon? previousWeapon = EquippedWeapon;
            if (EquippedWeapon != null)
            {
                EquippedWeapon = null;
            }
            return previousWeapon;
        }

        public int GetStrengthBonus()
        {
            return EquippedWeapon != null ? EquippedWeapon.StrengthBonus : 0;
        }
    }
}



================================================
FILE: src/ProjectTeam01/domain/generation/Corridor.cs
================================================
using System.Collections.Generic;

namespace ProjectTeam01.domain.generation;

/// Типы коридоров
public enum CorridorType
{
    LeftToRight,  // Горизонтальный коридор слева направо
    LeftTurn,     // Коридор с поворотом налево
    RightTurn,    // Коридор с поворотом направо
    TopToBottom   // Вертикальный коридор сверху вниз
}

/// Представляет коридор, соединяющий две комнаты
public class Corridor
{
    /// Тип коридора
    public CorridorType Type { get; set; }
    
    /// Ключевые точки коридора (для логики генерации)
    public List<Position> Points { get; set; }
    
    /// Все клетки коридора (для отрисовки и движения)
    public List<Position> Cells { get; set; }

    public Corridor()
    {
        Points = new List<Position>();
        Cells = new List<Position>();
    }
}




================================================
FILE: src/ProjectTeam01/domain/generation/DSU.cs
================================================
namespace ProjectTeam01.domain.generation;

/// Система непересекающихся множеств (DSU) для построения минимального остовного дерева
public class DSU
{
    private int[] _parent;
    private int[] _rank;

    public DSU(int size)
    {
        _parent = new int[size];
        _rank = new int[size];
        MakeSets();
    }

    /// Инициализирует DSU - каждая комната в своем множестве
    private void MakeSets()
    {   
        for (int i = 0; i < _parent.Length; i++)
        {
            _parent[i] = i;
            _rank[i] = 0;
        }
    }

    /// Находит корень множества для комнаты
    public int FindSet(int v)
    {
        if (v == _parent[v])
            return v;
        return _parent[v] = FindSet(_parent[v]);
    }

    /// Объединяет два множества
    public bool UnionSets(int v, int u)
    {
        v = FindSet(v);
        u = FindSet(u);

        if (u == v)
            return false;

        if (_rank[u] >= _rank[v])
        {
            _parent[v] = u;
            if (_rank[u] == _rank[v])
                _rank[u]++;
        }
        else
        {
            _parent[u] = v;
        }

        return true;
    }

    /// Проверить, что все элементы находятся в одном множестве (граф связный)
    public bool IsConnected()
    {
        if (_parent.Length == 0)
            return true;

        int root = FindSet(0);
        for (int i = 1; i < _parent.Length; i++)
        {
            if (FindSet(i) != root)
                return false;
        }
        return true;
    }

    /// Получить количество компонент связности
    public int GetConnectedComponentsCount()
    {
        var roots = new HashSet<int>();
        for (int i = 0; i < _parent.Length; i++)
        {
            roots.Add(FindSet(i));
        }
        return roots.Count;
    }
}




================================================
FILE: src/ProjectTeam01/domain/generation/EntityGenerator.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using ProjectTeam01.domain.Characters;
using ProjectTeam01.domain.Items;
using ProjectTeam01.domain.Effects;

namespace ProjectTeam01.domain.generation;

/// Генератор сущностей для размещения на уровне
internal class EntityGenerator
{
    private readonly Random _random;

    public EntityGenerator()
    {
        _random = new Random();
    }

    /// Разместить игрока в стартовой комнате
    public Hero PlacePlayer(Level level)
    {
        if (level == null) throw new ArgumentNullException(nameof(level));

        var hero = new Hero(level.StartPosition.X, level.StartPosition.Y);
        level.AddEntity(hero);

        return hero;
    }

    /// Разместить уже существующего героя на новом уровне (для перехода между уровнями).
    public void PlaceExistingHero(Level level, Hero hero)
    {
        if (level == null) throw new ArgumentNullException(nameof(level));
        if (hero == null) throw new ArgumentNullException(nameof(hero));

        hero.MoveTo(level.StartPosition.X, level.StartPosition.Y);
        level.AddEntity(hero);
    }

    /// Разместить врагов на уровне
    public void PlaceEnemies(Level level, int levelNumber)
    {
        if (level == null) throw new ArgumentNullException(nameof(level));

        int baseEnemyCount = 3 + levelNumber / 2; 
        int enemyCount = _random.Next(baseEnemyCount, baseEnemyCount + 5);

        var nonStartRooms = level.Rooms.Where(r => !r.IsStartRoom).ToList();
        if (nonStartRooms.Count == 0) return;

        for (int i = 0; i < enemyCount; i++)
        {
            var room = nonStartRooms[_random.Next(nonStartRooms.Count)];

            var position = GetRandomPositionInRoom(room);

            if (level.HasAnyEntityAt(position.X, position.Y))
            {
                position = FindFreePositionInRoom(room, level);
                if (position.X == -1) continue; 
            }

            var enemy = CreateRandomEnemy(position.X, position.Y);
            level.AddEntity(enemy);
        }
    }

    /// Разместить предметы на уровне
    public void PlaceItems(Level level, int levelNumber)
    {
        if (level == null) throw new ArgumentNullException(nameof(level));

        int baseItemCount = 10 - levelNumber / 3; 
        int itemCount = Math.Max(3, _random.Next(baseItemCount, baseItemCount + 5));

        var nonStartRooms = level.Rooms.Where(r => !r.IsStartRoom).ToList();
        if (nonStartRooms.Count == 0) return;

        for (int i = 0; i < itemCount; i++)
        {
            var room = nonStartRooms[_random.Next(nonStartRooms.Count)];

            var position = GetRandomPositionInRoom(room);

            if (level.HasAnyEntityAt(position.X, position.Y))
            {
                position = FindFreePositionInRoom(room, level);
                if (position.X == -1) continue;
            }

            var item = CreateRandomItem(position.X, position.Y, levelNumber);
            level.AddEntity(item);
        }
    }

    /// Получить случайную позицию в комнате
    private Position GetRandomPositionInRoom(Room room)
    {
        int minX = room.TopLeft.X + 1;
        int maxX = room.BottomRight.X - 1;
        int minY = room.TopLeft.Y + 1;
        int maxY = room.BottomRight.Y - 1;

        if (minX >= maxX) minX = maxX = room.TopLeft.X;
        if (minY >= maxY) minY = maxY = room.TopLeft.Y;

        int x = _random.Next(minX, maxX + 1);
        int y = _random.Next(minY, maxY + 1);

        return new Position(x, y);
    }

    /// Найти свободную позицию в комнате
    private Position FindFreePositionInRoom(Room room, Level level)
    {
        int minX = room.TopLeft.X + 1;
        int maxX = room.BottomRight.X - 1;
        int minY = room.TopLeft.Y + 1;
        int maxY = room.BottomRight.Y - 1;

        if (minX >= maxX) minX = maxX = room.TopLeft.X;
        if (minY >= maxY) minY = maxY = room.TopLeft.Y;

        for (int attempt = 0; attempt < 20; attempt++)
        {
            int x = _random.Next(minX, maxX + 1);
            int y = _random.Next(minY, maxY + 1);

            if (!level.HasAnyEntityAt(x, y))
            {
                return new Position(x, y);
            }
        }

        return new Position(-1, -1);
    }

    /// Создать случайного врага
    private Enemy CreateRandomEnemy(int x, int y)
    {
        var enemyType = (EnemyTypeEnum)_random.Next(0, 6);

        return enemyType switch
        {
            EnemyTypeEnum.Zombie => new Zombie(x, y),
            EnemyTypeEnum.Vampire => new Vampire(x, y),
            EnemyTypeEnum.Ghost => new Ghost(x, y),
            EnemyTypeEnum.Ogre => new Ogre(x, y),
            EnemyTypeEnum.Snake => new Snake(x, y),
            EnemyTypeEnum.Mimic => new Mimic(x, y),
            _ => new Zombie(x, y)
        };
    }

    /// Создать случайный предмет
    private Item CreateRandomItem(int x, int y, int levelNumber)
    {
        int roll = _random.Next(0, 100);

        if (roll < 35)
        {
            int healthValue = _random.Next(5, 21); 
            return new Food(healthValue, x, y);
        }
        else if (roll < 60)
        {
            var elixirType = (EffectTypeEnum)_random.Next(0, 3);
            return new Elixir(elixirType, x, y);
        }
        else if (roll < 80)
        {
            var scrollType = (ScrollTypeEnum)_random.Next(0, 3);
            return new Scroll(scrollType, x, y);
        }
        else
        {
            var weaponType = (WeaponTypeEnum)_random.Next(0, 4);
            return new Weapon(weaponType, x, y);
        }
    }
}




================================================
FILE: src/ProjectTeam01/domain/generation/IMapQuery.cs
================================================
namespace ProjectTeam01.domain.generation;

/// Интерфейс для запросов к карте/уровню.
internal interface IMapQuery
{
    bool IsOccupied(int x, int y);
    int GetDistance(int x1, int y1, int x2, int y2);
    int GetMapLevel();
    void RemoveObject(IGameObject obj);
    Room? FindRoomAt(int x, int y);
    Corridor? FindCorridorAt(int x, int y);
}




================================================
FILE: src/ProjectTeam01/domain/generation/Level.cs
================================================
using System;
using System.Collections.Generic;
using System.Linq;
using ProjectTeam01.domain;
using ProjectTeam01.domain.Characters;
using ProjectTeam01.domain.Items;

namespace ProjectTeam01.domain.generation;

/// Представляет уровень подземелья с комнатами, коридорами и сущностями
public class Level
{
    /// Геометрия уровня
    public List<Room> Rooms { get; set; }
    public List<Corridor> Corridors { get; set; }
    public int LevelNumber { get; set; }
    public Position ExitPosition { get; set; }
    public Position StartPosition { get; set; }
    
    /// Сущности уровня 
    private readonly List<IGameObject> _entities;

    /// Индекс для быстрого поиска сущностей по координатам
    private Dictionary<Position, List<IGameObject>> _positionIndex;
    private bool _indexDirty = true;

    /// Конструктор уровня
    public Level()
    {
        Rooms = new List<Room>();
        Corridors = new List<Corridor>();
        _entities = new List<IGameObject>();
        _positionIndex = new Dictionary<Position, List<IGameObject>>();
        ExitPosition = new Position();
        StartPosition = new Position();
    }
    
    /// Получить все сущности уровня
    public IReadOnlyList<IGameObject> Entities => _entities.AsReadOnly();
    
    /// Проверить, можно ли пройти по позиции (геометрия)
    public bool IsWalkable(int x, int y)
    {
        var pos = new Position(x, y);
        
        // Проверка комнат
        foreach (var room in Rooms)
        {
            bool isInsideRoom = pos.X > room.TopLeft.X && pos.X < room.BottomRight.X &&
                               pos.Y > room.TopLeft.Y && pos.Y < room.BottomRight.Y;
            
            bool isDoor = room.Doors != null && room.Doors.Any(door => 
                (door.X != 0 || door.Y != 0) && door.X == pos.X && door.Y == pos.Y);
            
            if (isInsideRoom || isDoor)
                return true;
        }
        
        // Проверка коридоров
        foreach (var corridor in Corridors)
        {
            if (corridor.Cells != null && corridor.Cells.Contains(pos))
                return true;
        }
        
        return false;
    }
    /// Проверить, заблокирована ли клетка актором (игрок/враг).
    /// Предметы клетку не блокируют.
    public bool IsOccupied(int x, int y)
    {
        EnsureIndex();
        var pos = new Position(x, y);
        return _positionIndex.TryGetValue(pos, out var list) && list.Any(IsBlockingEntity);
    }

    /// Проверить, есть ли на клетке хоть какая-то сущность (включая предметы)
    public bool HasAnyEntityAt(int x, int y)
    {
        EnsureIndex();
        return _positionIndex.ContainsKey(new Position(x, y));
    }
    
    /// Получить сущность по позиции
    public IGameObject? GetEntityAt(int x, int y)
    {
        EnsureIndex();
        if (_positionIndex.TryGetValue(new Position(x, y), out var list) && list.Count > 0)
            return list[0];

        return null;
    }
    
    /// Получить все сущности на позиции
    public IReadOnlyList<IGameObject> GetEntitiesAt(int x, int y)
    {
        EnsureIndex();
        var pos = new Position(x, y);
        return _positionIndex.TryGetValue(pos, out var list)
            ? list.AsReadOnly()
            : Array.Empty<IGameObject>();
    }
    
    /// Получить всех врагов на уровне
    internal IReadOnlyList<Characters.Enemy> GetEnemies()
    {
        return _entities.OfType<Characters.Enemy>().ToList().AsReadOnly();
    }
    
    /// Получить все предметы на уровне
    internal IReadOnlyList<Items.Item> GetItems()
    {
        return _entities.OfType<Items.Item>().ToList().AsReadOnly();
    }
    
    /// Найти комнату, в которой находится указанная позиция
    internal Room? FindRoomAt(int x, int y)
    {
        var pos = new Position(x, y);
        foreach (var room in Rooms)
        {
            if (pos.X >= room.TopLeft.X && pos.X <= room.BottomRight.X &&
                pos.Y >= room.TopLeft.Y && pos.Y <= room.BottomRight.Y)
                return room;
        }
        return null;
    }
    
    /// Найти коридор, в котором находится указанная позиция
    internal Corridor? FindCorridorAt(int x, int y)
    {
        var pos = new Position(x, y);
        foreach (var corridor in Corridors)
        {
            if (corridor.Cells != null && corridor.Cells.Contains(pos))
                return corridor;
        }
        return null;
    }
    
    /// Добавить сущность на уровень
    public void AddEntity(IGameObject entity)
    {
        if (entity == null) return;
        
        _entities.Add(entity);
        _indexDirty = true;
    }
    
    /// Удалить сущность с уровня
    public void RemoveEntity(IGameObject entity)
    {
        if (entity == null) return;
        
        _entities.Remove(entity);
        _indexDirty = true;
    }
    
    /// Обновить позицию сущности в индексе (при движении)
    public void UpdateEntityPosition(IGameObject entity, Position oldPosition)
    {
        EnsureIndex();

        if (_positionIndex.TryGetValue(oldPosition, out var oldList))
        {
            oldList.Remove(entity);
            if (oldList.Count == 0)
                _positionIndex.Remove(oldPosition);
        }

        if (!_positionIndex.TryGetValue(entity.Position, out var newList))
        {
            newList = new List<IGameObject>();
            _positionIndex[entity.Position] = newList;
        }
        newList.Add(entity);
    }
    
    /// Обновить индекс позиций (ленивая инициализация)
    private void EnsureIndex()
    {
        if (_indexDirty)
        {
            _positionIndex = new Dictionary<Position, List<IGameObject>>();

            foreach (var entity in _entities)
            {
                if (!_positionIndex.TryGetValue(entity.Position, out var list))
                {
                    list = new List<IGameObject>();
                    _positionIndex[entity.Position] = list;
                }
                list.Add(entity);
            }
            
            _indexDirty = false;
        }
    }

    private static bool IsBlockingEntity(IGameObject entity)
    {
        return entity is Hero || entity is Enemy;
    }
}




================================================
FILE: src/ProjectTeam01/domain/generation/LevelGenerator.cs
================================================
[Binary file]


================================================
FILE: src/ProjectTeam01/domain/generation/LevelMapQuery.cs
================================================
using System;
using System.Collections.Generic;

namespace ProjectTeam01.domain.generation;

/// Адаптер для использования Level через интерфейс IMapQuery для работы с картой без прямой зависимости от Level.

internal sealed class LevelMapQuery : IMapQuery
{
    private readonly Level _level;
  
    public LevelMapQuery(Level level)
    {
        _level = level ?? throw new ArgumentNullException(nameof(level));
    }

    public bool IsOccupied(int x, int y)
    {
        if (!_level.IsWalkable(x, y))
            return true;

        return _level.IsOccupied(x, y);
    }

    public int GetDistance(int x1, int y1, int x2, int y2)
    {
        if (x1 == x2 && y1 == y2)
            return 0;

        if (!_level.IsWalkable(x1, y1))
            return int.MaxValue;
        if (!_level.IsWalkable(x2, y2))
            return int.MaxValue;

        int height = GenerationConstants.MapHeight;
        int width = GenerationConstants.MapWidth;

        if (x1 < 0 || x1 >= width || y1 < 0 || y1 >= height)
            return int.MaxValue;
        if (x2 < 0 || x2 >= width || y2 < 0 || y2 >= height)
            return int.MaxValue;

        var visited = new bool[height, width];
        var q = new Queue<(int x, int y, int d)>();

        visited[y1, x1] = true;
        q.Enqueue((x1, y1, 0));

        while (q.Count > 0)
        {
            var (cx, cy, cd) = q.Dequeue();

            for (int dx = -1; dx <= 1; dx++)
            {
                for (int dy = -1; dy <= 1; dy++)
                {
                    if (dx == 0 && dy == 0) continue;

                    int nx = cx + dx;
                    int ny = cy + dy;

                    if (nx < 0 || nx >= width || ny < 0 || ny >= height)
                        continue;
                    if (visited[ny, nx])
                        continue;

                    if (!_level.IsWalkable(nx, ny))
                        continue;

                    if (_level.IsOccupied(nx, ny) && !(nx == x2 && ny == y2))
                        continue;

                    if (nx == x2 && ny == y2)
                        return cd + 1;

                    visited[ny, nx] = true;
                    q.Enqueue((nx, ny, cd + 1));
                }
            }
        }

        return int.MaxValue;
    }

    public int GetMapLevel()
    {
        return _level.LevelNumber;
    }

    public void RemoveObject(IGameObject obj)
    {
        _level.RemoveEntity(obj);
    }

    public Room? FindRoomAt(int x, int y)
    {
        return _level.FindRoomAt(x, y);
    }

    public Corridor? FindCorridorAt(int x, int y)
    {
        return _level.FindCorridorAt(x, y);
    }
}





================================================
FILE: src/ProjectTeam01/domain/generation/Position.cs
================================================
namespace ProjectTeam01.domain.generation;

/// Представляет координаты точки на карте
public struct Position
{
    public int X { get; }
    public int Y { get; }

    public Position(int x, int y)
    {
        X = x;
        Y = y;
    }

    public override bool Equals(object? obj)
    {
        return obj is Position other && X == other.X && Y == other.Y;
    }

    public override int GetHashCode()
    {
        return HashCode.Combine(X, Y);
    }
}


================================================
FILE: src/ProjectTeam01/domain/generation/RenderExample.cs
================================================
using System;
using ProjectTeam01.domain;
using ProjectTeam01.domain.Characters;
using ProjectTeam01.domain.Session;
using ProjectTeam01.presentation;
using ProjectTeam01.presentation.Mappers;

namespace ProjectTeam01.domain.generation;

/// Пример использования GameStateRenderer для отрисовки уровня через ViewModels
/// Этот класс можно использовать для тестирования отрисовки
public static class RenderExample
{
    /// Генерирует и отрисовывает уровень через ViewModels
    public static void GenerateAndRender()
    {
        var generator = new LevelGenerator();
        var level = generator.GenerateLevel();
        
        // Создаем героя и игровую сессию для получения ViewModel
        var hero = new Hero(level.StartPosition.X, level.StartPosition.Y);
        var gameSession = new GameSession(level, hero, level.LevelNumber);
        
        // Получаем ViewModel и отрисовываем
        var gameState = gameSession.GetGameState();
        var viewModel = GameStateMapper.ToViewModel(gameState);
        
        // GameStateRenderer.Render(viewModel);
        
        Console.WriteLine();
        Console.WriteLine($"Level Number: {viewModel.CurrentLevelNumber}");
        Console.WriteLine($"Rooms Count: {viewModel.Level.Rooms.Count}");
        Console.WriteLine($"Corridors Count: {viewModel.Level.Corridors.Count}");
        Console.WriteLine($"Start Position: ({viewModel.Level.StartPosition.X}, {viewModel.Level.StartPosition.Y})");
        Console.WriteLine($"Exit Position: ({viewModel.Level.ExitPosition.X}, {viewModel.Level.ExitPosition.Y})");
        Console.WriteLine();
        Console.WriteLine("Press any key to exit...");
        Console.ReadKey();
    }
}




================================================
FILE: src/ProjectTeam01/domain/generation/Room.cs
================================================
﻿using System.Collections.Generic;

namespace ProjectTeam01.domain.generation;

/// Направления для соединений комнат
public enum Direction
{
    Top = 0,
    Right = 1,
    Bottom = 2,
    Left = 3
}

/// Представляет комнату на уровне
public class Room
{
    public int Sector { get; set; } // Индекс секции (0-8)

    // Геометрия комнаты
    public Position TopLeft { get; set; }
    public Position BottomRight { get; set; }

    // Двери в комнате (по направлениям)
    public Position[] Doors { get; set; }

    // Соединения с другими комнатами
    public Room[] Connections { get; set; }

    // Флаги специальных комнат
    public bool IsStartRoom { get; set; }
    public bool IsEndRoom { get; set; }

    public Room()
    {
        Doors = new Position[4];
        Connections = new Room[4];
        TopLeft = new Position();
        BottomRight = new Position();
        Sector = -1; // -1 означает неинициализированную комнату
    }

    /// Получить ширину комнаты
    public int Width => BottomRight.X - TopLeft.X + 1;

    /// Получить высоту комнаты
    public int Height => BottomRight.Y - TopLeft.Y + 1;
}



================================================
FILE: src/ProjectTeam01/domain/Items/Elixir.cs
================================================
﻿using static ProjectTeam01.domain.Effects.ActiveEffect;
using ProjectTeam01.domain.Items.Interfaces;
using ProjectTeam01.domain.Characters;
using ProjectTeam01.domain.Effects;

namespace ProjectTeam01.domain.Items
{
    internal class Elixir : Item, IUsableItem
    {
        private const int MaxPercentAgilityIncrease = 10;
        private const int MaxPercentStrengthIncrease = 10;
        private const int MaxPercentMaxHpIncrease = 20;
        private const int MinElixirDurationSeconds = 30;
        private const int MaxElixirDurationSeconds = 60;

        public Elixir(EffectTypeEnum elixirType, int posX, int posY) : base(ItemType.Elixir, posX, posY)
        {
            ElixirType = elixirType;
        }

        void IUsableItem.Use(Hero hero)
        {
            if (!hero.HeroBackpack.AllItems.Contains(this))
                return;

            var random = Random.Shared;

            int value = CalculateValue(hero, random);
            int durationSeconds = random.Next(MinElixirDurationSeconds, MaxElixirDurationSeconds + 1);
            int durationTicks = durationSeconds;

            ActiveEffect effect = new ActiveEffect(ElixirType, value, durationTicks);
            hero.ActiveEffectManager.AddActiveEffect(effect);
        }

        private int CalculateValue(Hero hero, Random random)
        {
            int maxIncrease = ElixirType switch
            {
                EffectTypeEnum.BuffAgility => hero.BaseAgility * MaxPercentAgilityIncrease / 100,
                EffectTypeEnum.BuffStrength => hero.BaseStrength * MaxPercentStrengthIncrease / 100,
                EffectTypeEnum.BuffMaxHp => hero.MaxHp * MaxPercentMaxHpIncrease / 100,
                _ => 1
            };

            return random.Next(1, Math.Max(2, maxIncrease + 1));
        }

        public EffectTypeEnum ElixirType { get; }
    }
}



================================================
FILE: src/ProjectTeam01/domain/Items/Food.cs
================================================
﻿using ProjectTeam01.domain.Characters;
using ProjectTeam01.domain.Items.Interfaces;

namespace ProjectTeam01.domain.Items
{
    internal class Food : Item, IUsableItem
    {
        /// Количество HP, которое восстанавливает эта еда
        public int HealthValue { get; }

        public Food(int healthValue, int posX, int posY) : base(ItemType.Food, posX, posY)
        {
            HealthValue = healthValue;
        }

        void IUsableItem.Use(Hero hero)
        {
            // Восстанавливаем HP, но не больше максимума
            int healAmount = HealthValue;
            int missingHp = hero.MaxHp - hero.ActualHp;
            if (healAmount > missingHp)
                healAmount = missingHp;
            
            hero.Heal(healAmount);
        }
    }
}



================================================
FILE: src/ProjectTeam01/domain/Items/Item.cs
================================================
﻿namespace ProjectTeam01.domain.Items
{
    /// Тип предмета для использования в ViewModels и других публичных API
    public enum ItemType
    {
        Treasure,
        Food,
        Elixir,
        Scroll,
        Weapon
    }

    internal abstract class Item: GameObject
    {
        public ItemType Type { get; }

        protected Item(ItemType type, int posX, int posY) : base(posX, posY)
        {
            Type = type;
        }
    }
}



================================================
FILE: src/ProjectTeam01/domain/Items/Scroll.cs
================================================
﻿using ProjectTeam01.domain.Characters;
using ProjectTeam01.domain.Items.Interfaces;

namespace ProjectTeam01.domain.Items
{
    public enum ScrollTypeEnum
    {
        Agility,
        Strength,
        MaxHp
    }

    internal class Scroll(ScrollTypeEnum scrollType, int posX, int posY) : Item(ItemType.Scroll, posX, posY), IUsableItem
    {
        public ScrollTypeEnum ScrollType { get; } = scrollType;

        void IUsableItem.Use(Hero hero)
        {
            switch (ScrollType)
            {
                case ScrollTypeEnum.Agility:
                    hero.ChangeBaseAgility(5);
                    break;
                case ScrollTypeEnum.Strength:
                    hero.ChangeBaseStrength(5);
                    break;
                case ScrollTypeEnum.MaxHp:
                    hero.ChangeBaseMaxHp(10);
                    hero.Heal(10);
                    break;
                default:
                    break;
            }
        }


    }

}



================================================
FILE: src/ProjectTeam01/domain/Items/Treasure.cs
================================================
﻿namespace ProjectTeam01.domain.Items
{
    internal class Treasure : Item
    {
        public Treasure(int posX, int posY, int lvl) : base(ItemType.Treasure, posX, posY)
        {
            Level = lvl;
        }
        public int Price { get; set; }
        public int Level { get; } 
    }
}



================================================
FILE: src/ProjectTeam01/domain/Items/Weapon.cs
================================================
﻿namespace ProjectTeam01.domain.Items
{
    public enum WeaponTypeEnum
    {
        Axe,
        Dagger,
        Sword,
        Bow
    }
    internal class Weapon : Item
    {
        public Weapon(WeaponTypeEnum weaponType, int posX, int posY) : base(ItemType.Weapon, posX, posY)
        {
            WeaponType = weaponType;
        }

        public WeaponTypeEnum WeaponType { get; }

        public int StrengthBonus
        {
            get
            {
                switch (WeaponType)
                {
                    case WeaponTypeEnum.Axe:
                        return 5;
                    case WeaponTypeEnum.Dagger:
                        return 2;
                    case WeaponTypeEnum.Sword:
                        return 3;
                    case WeaponTypeEnum.Bow:
                        return 4;
                    default:
                        return 0;
                }
            }
        }
    }
}



================================================
FILE: src/ProjectTeam01/domain/Items/Interfaces/IUsableItem.cs
================================================
﻿using ProjectTeam01.domain.Characters;

namespace ProjectTeam01.domain.Items.Interfaces
{
    internal interface IUsableItem
    {
         void Use(Hero hero);
    }
}



================================================
FILE: src/ProjectTeam01/domain/Session/GameInitializer.cs
================================================
using ProjectTeam01.domain.generation;

namespace ProjectTeam01.domain.Session;

/// Инициализатор игры - создает новую игровую сессию.
/// Отвечает за генерацию уровня, размещение сущностей и создание GameSession.
internal static class GameInitializer
{
    /// Создать новую игру и вернуть GameSession.
    public static GameSession CreateNewGame(int levelNumber = 1)
    {
        // Генерируем уровень
        var levelGenerator = new LevelGenerator();
        var level = levelGenerator.GenerateLevel();
        level.LevelNumber = levelNumber;

        // Генерируем сущности
        var entityGenerator = new EntityGenerator();
        var hero = entityGenerator.PlacePlayer(level);
        entityGenerator.PlaceEnemies(level, levelNumber);
        entityGenerator.PlaceItems(level, levelNumber);

        // Создаем и возвращаем GameSession (с новой статистикой)
        return new GameSession(level, hero, levelNumber);
    }
}




================================================
FILE: src/ProjectTeam01/domain/Session/GameSession.Combat.cs
================================================
using ProjectTeam01.domain.Characters;
using ProjectTeam01.domain.Combat;
using ProjectTeam01.domain.Effects;
using ProjectTeam01.domain.Items;

namespace ProjectTeam01.domain.Session;
// отвечает за логику боя
internal partial class GameSession
{
    /// Обработать бой с врагом
    public CombatResult ProcessCombat(Enemy enemy)
    {
        if (enemy == null || enemy.IsDead) return CombatResult.NoCombat;

        // Игрок атакует врага
        bool playerHit = BattleService.HitSuccess(Player.Agility, enemy.BaseAgility);
        if (enemy is Vampire vampire && !vampire.EvadedFirstAttack)
        {
            vampire.EvadedFirstAttack = true;
            playerHit = false;
        }
        _statistics.RecordPlayerHitAttempt(playerHit);
        if (playerHit)
        {
            int playerDamage = CalculatePlayerDamage();
            enemy.TakeDamage(playerDamage);
        }

        if (enemy.IsDead)
        {
            int lootValue = CalculateTreasureValue(enemy);
            var treasure = new Treasure(enemy.Position.X, enemy.Position.Y, _currentLevel.LevelNumber) { Price = lootValue };
            Player.HeroBackpack.Add(treasure);
            _statistics.RecordTreasureCollected(lootValue);
            _statistics.RecordEnemyDefeated();

            _currentLevel.RemoveEntity(enemy);

            return CombatResult.EnemyDefeated;
        }

        bool alwaysHit = enemy is Ogre;
        bool enemyHit = BattleService.HitSuccess(enemy.BaseAgility, Player.Agility, alwaysHit);
        if (enemyHit)
        {
            int enemyDamage = CalculateEnemyDamage(enemy);
            Player.TakeDamage(enemyDamage);
            _statistics.RecordHitTaken();
            ApplyEnemySpecialOnHit(enemy);
        }

        if (Player.IsDead)
        {
            return CombatResult.PlayerDefeated;
        }

        return CombatResult.Ongoing;
    }

    /// Рассчитать урон игрока
    private int CalculatePlayerDamage()
    {
        // Если есть оружие: weapon_strength * (strength + 65) / 100
        if (Player.WeaponManager.EquippedWeapon != null)
        {
            int weaponStrength = Player.WeaponManager.EquippedWeapon.StrengthBonus;
            int totalStrength = Player.BaseStrength + Player.ActiveEffectManager.GetTotalStatBonus(EffectTypeEnum.BuffStrength);
            return (int)Math.Round(weaponStrength * (totalStrength + BattleConstants.StrengthAddition) / 100.0);
        }
        // Без оружия: 30 + (strength - 50) * 0.3
        else
        {
            int totalStrength = Player.BaseStrength + Player.ActiveEffectManager.GetTotalStatBonus(EffectTypeEnum.BuffStrength);
            return (int)Math.Round(BattleConstants.InitialDamage 
                + (totalStrength - BattleConstants.StandardStrength) * BattleConstants.StrengthFactor);
        }
    }

    /// Рассчитать урон врага (формула из rogue_sample)
    private int CalculateEnemyDamage(Enemy enemy)
    {
        return enemy switch
        {
            Vampire => CalculateVampireDamage(),
            Ogre => CalculateOgreDamage(enemy),
            _ => CalculateStandardEnemyDamage(enemy) 
        };
    }

    /// Урон стандартных врагов 30 + (strength - 50) * 0.3
    private int CalculateStandardEnemyDamage(Enemy enemy)
    {
        return (int)Math.Round(BattleConstants.InitialDamage 
            + (enemy.BaseStrength - BattleConstants.StandardStrength) * BattleConstants.StrengthFactor);
    }

    /// Урон вампира: max_hp / 10 (отнимает часть максимального HP)
    private int CalculateVampireDamage()
    {
        return Player.MaxHp / BattleConstants.MaxHpPart;
    }

    /// Урон огра: (strength - 50) * 0.3 (без базового урона, раз в два хода)
    private int CalculateOgreDamage(Enemy ogre)
    {
        if (ogre is not Ogre ogreEnemy)
            return 0;

        int damage = 0;
        if (!ogreEnemy.OgreCooldown)
        {
            damage = (int)Math.Round((ogre.BaseStrength - BattleConstants.StandardStrength) * BattleConstants.StrengthFactor);
            ogreEnemy.OgreCooldown = true;
        }
        else
        {
            ogreEnemy.OgreCooldown = false;
        }

        return damage;
    }

    /// Расчет сокровищ за врага
    private int CalculateTreasureValue(Enemy enemy)
    {
        // loot = agility * 0.2 + health * 0.5 + strength * 0.5 + random(0, 20)
        int baseLoot = (int)Math.Round(
            enemy.BaseAgility * BattleConstants.LootAgilityFactor
            + enemy.ActualHp * BattleConstants.LootHpFactor
            + enemy.BaseStrength * BattleConstants.LootStrengthFactor
            + _random.Next(0, BattleConstants.LootRandomMax + 1)
        );
        
        int levelBonus = (int)Math.Round(baseLoot * _currentLevel.LevelNumber * 0.05);
        return baseLoot + levelBonus;
    }

    private void ApplyEnemySpecialOnHit(Enemy enemy)
    {
        switch (enemy)
        {
            case Ghost ghost:
                ghost.IsInvisible = false;
                break;
            case Ogre ogre:
                break;
            case Snake:
                if (_random.Next(0, 100) < Snake.SleepChancePercent)
                    Player.ActiveEffectManager.AddActiveEffect(new ActiveEffect(EffectTypeEnum.Sleep));
                break;
        }
    }
}





================================================
FILE: src/ProjectTeam01/domain/Session/GameSession.cs
================================================
[Binary file]


================================================
FILE: src/ProjectTeam01/domain/Session/GameSession.Enemies.cs
================================================
using System.Linq;
using ProjectTeam01.domain.Characters;
using ProjectTeam01.domain.Characters.Behavior;
using ProjectTeam01.domain.generation;

namespace ProjectTeam01.domain.Session;
// отвечает за логику хода врагов
internal partial class GameSession
{
    /// Обработать ход врагов
    public void ProcessEnemiesTurn(Enemy? skipEnemy = null)
    {
        _mapQuery = new LevelMapQuery(_currentLevel);

        foreach (var enemy in _currentLevel.GetEnemies().ToList())
        {
            if (skipEnemy != null && ReferenceEquals(enemy, skipEnemy))
                continue;

            if (!enemy.IsDead)
            {
                var behavior = CreateEnemyBehavior(enemy);
                if (behavior == null) continue;

                int hpBefore = Player.ActualHp;
                var oldPos = enemy.Position;

                behavior.Tick(Player);

                if (!enemy.Position.Equals(oldPos))
                    _currentLevel.UpdateEntityPosition(enemy, oldPos);

                if (Player.ActualHp < hpBefore)
                    _statistics.RecordHitTaken();
            }
        }
    }

    private EnemyBehavior? CreateEnemyBehavior(Enemy enemy)
    {
        return enemy.EnemyType switch
        {
            EnemyTypeEnum.Zombie when enemy is Zombie z => new ZombieBehavior(z, _mapQuery),
            EnemyTypeEnum.Vampire when enemy is Vampire v => new VampireBehavior(v, _mapQuery),
            EnemyTypeEnum.Ghost when enemy is Ghost g => new GhostBehavior(g, _mapQuery),
            EnemyTypeEnum.Ogre when enemy is Ogre o => new OgreBehavior(o, _mapQuery),
            EnemyTypeEnum.Snake when enemy is Snake s => new SnakeBehavior(s, _mapQuery),
            EnemyTypeEnum.Mimic when enemy is Mimic m => new MimicBehavior(m, _mapQuery),
            _ => null
        };
    }
}





================================================
FILE: src/ProjectTeam01/domain/Session/GameSession.Inventory.cs
================================================
using System.Collections.Generic;
using System.Linq;
using ProjectTeam01.domain.Items;
using ProjectTeam01.domain.generation;

namespace ProjectTeam01.domain.Session;
// отвечает за логику инвентаря
internal partial class GameSession
{
    /// Подобрать предмет
    public void PickupItem(Item item)
    {
        if (item == null) return;

        if (Player.HeroBackpack.Add(item))
        {
            _currentLevel.RemoveEntity(item);
        }
    }

    /// Использовать предмет игроком
    public bool UsePlayerItem(Item item)
    {
        if (item == null) return false;
        bool used = Player.HeroBackpack.UseItem(item, Player);
        if (!used) return false;

        switch (item)
        {
            case Food:
                _statistics.RecordFoodConsumed();
                break;
            case Elixir:
                _statistics.RecordElixirConsumed();
                break;
            case Scroll:
                _statistics.RecordScrollConsumed();
                break;
        }

        return true;
    }

    /// Экипировать оружие
    public bool EquipPlayerWeapon(Weapon weapon)
    {
        if (weapon == null) return false;

        if (!Player.HeroBackpack.AllItems.Contains(weapon))
            return false;

        var previousWeapon = Player.WeaponManager.EquippedWeapon;

        bool success = Player.HeroBackpack.EquipWeapon(weapon, Player);

        if (success && previousWeapon != null)
        {
            if (Player.HeroBackpack.AllItems.Contains(previousWeapon))
            {
                Player.HeroBackpack.DeleteItem(previousWeapon);
            }

            var dropPosition = FindFreeNeighborPosition(Player.Position);
            if (dropPosition != null)
            {
                previousWeapon.MoveTo(dropPosition.Value.X, dropPosition.Value.Y);
                _currentLevel.AddEntity(previousWeapon);
            }
            else
            {
                previousWeapon.MoveTo(Player.Position.X, Player.Position.Y);
                _currentLevel.AddEntity(previousWeapon);
            }
        }

        return success;
    }

    /// Убрать оружие из рук, не выбрасывая из инвентаря (по ТЗ выбор 0 в списке оружия).
    public bool UnequipPlayerWeapon()
    {
        return Player.WeaponManager.UnequipWeapon() != null;
    }

    /// Выбросить предмет
    public bool DropPlayerItem(Item item)
    {
        if (item == null) return false;

        if (!Player.HeroBackpack.AllItems.Contains(item))
            return false;

        Player.HeroBackpack.DeleteItem(item);

        var dropPosition = FindFreeNeighborPosition(Player.Position);
        if (dropPosition != null)
        {
            item.MoveTo(dropPosition.Value.X, dropPosition.Value.Y);
            _currentLevel.AddEntity(item);
            return true;
        }

        Player.HeroBackpack.Add(item);
        return false;
    }

    /// Найти свободную соседнюю позицию
    private Position? FindFreeNeighborPosition(Position center)
    {
        for (int dx = -1; dx <= 1; dx++)
        {
            for (int dy = -1; dy <= 1; dy++)
            {
                if (dx == 0 && dy == 0) continue;

                int newX = center.X + dx;
                int newY = center.Y + dy;

                if (_currentLevel.IsWalkable(newX, newY) && !_currentLevel.HasAnyEntityAt(newX, newY))
                {
                    return new Position(newX, newY);
                }
            }
        }

        return null;
    }

    /// Получить оружие игрока
    public IReadOnlyList<Weapon> GetPlayerWeapons() => Player.HeroBackpack.AllItems.OfType<Weapon>().ToList().AsReadOnly();

    /// Получить еду игрока
    public IReadOnlyList<Food> GetPlayerFood() => Player.HeroBackpack.AllItems.OfType<Food>().ToList().AsReadOnly();

    /// Получить эликсиры игрока
    public IReadOnlyList<Elixir> GetPlayerElixirs() => Player.HeroBackpack.AllItems.OfType<Elixir>().ToList().AsReadOnly();

    /// Получить свитки игрока
    public IReadOnlyList<Scroll> GetPlayerScrolls() => Player.HeroBackpack.AllItems.OfType<Scroll>().ToList().AsReadOnly();
    public int GetTotalGold()
    {
        var treasure = Player.HeroBackpack.AllItems.OfType<Treasure>().ToList();
        return treasure.Count>0? treasure[0].Price:0;
    } 
}





================================================
FILE: src/ProjectTeam01/domain/Session/GameSession.Leveling.cs
================================================
using System;
using ProjectTeam01.domain.generation;

namespace ProjectTeam01.domain.Session;
//отвечает за логику перехода на следующий уровень
internal partial class GameSession
{
    /// Проверить, находится ли игрок на выходе
    public bool IsPlayerAtExit() => Player.Position.Equals(_currentLevel.ExitPosition);

    /// Проверить, закончена ли игра (игрок мертв)
    public bool IsGameOver() => Player.IsDead;

    public bool IsLastLevel() => _currentLevel.LevelNumber >= 21;

    /// Проверить, нужно ли перейти на следующий уровень
    public bool ShouldAdvanceLevel() => IsPlayerAtExit();

    private void AdvanceToNextLevelInternal()
    {
        int nextLevelNumber = _currentLevel.LevelNumber + 1;
        var next = _levelGenerator.GenerateLevel();
        next.LevelNumber = nextLevelNumber;

        _entityGenerator.PlaceExistingHero(next, Player);
        _entityGenerator.PlaceEnemies(next, nextLevelNumber);
        _entityGenerator.PlaceItems(next, nextLevelNumber);

        _currentLevel = next;
        _mapQuery = new LevelMapQuery(_currentLevel);
        _statistics.RecordLevelReached(nextLevelNumber);
    }

    /// Перейти на следующий уровень (внешний вызов)
    public void AdvanceToNextLevel(Level nextLevel)
    {
        if (nextLevel == null) throw new ArgumentNullException(nameof(nextLevel));

        int nextLevelNumber = _currentLevel.LevelNumber + 1;
        nextLevel.LevelNumber = nextLevelNumber;
        _entityGenerator.PlaceExistingHero(nextLevel, Player);
        _entityGenerator.PlaceEnemies(nextLevel, nextLevelNumber);
        _entityGenerator.PlaceItems(nextLevel, nextLevelNumber);

        _currentLevel = nextLevel;
        _mapQuery = new LevelMapQuery(_currentLevel);
        _statistics.RecordLevelReached(nextLevelNumber);
    }
}





================================================
FILE: src/ProjectTeam01/domain/Session/GameSession.Movement.cs
================================================
using System.Linq;
using ProjectTeam01.domain.generation;

namespace ProjectTeam01.domain.Session;
// отвечает за логику перемещения
internal partial class GameSession
{
    /// Переместить сущность на новую позицию
    public bool MoveEntity(IGameObject entity, int newX, int newY)
    {
        if (entity == null) return false;

        if (!_currentLevel.IsWalkable(newX, newY))
            return false;

        if (entity.Position.X != newX || entity.Position.Y != newY)
        {
            if (_currentLevel.IsOccupied(newX, newY))
                return false;
        }

        var oldPos = entity.Position;
        entity.MoveTo(newX, newY);
        _currentLevel.UpdateEntityPosition(entity, oldPos);

        return true;
    }

    /// Переместить игрока
    public bool MovePlayer(int newX, int newY)
    {
        bool moved = MoveEntity(Player, newX, newY);
        if (moved)
        {
            _statistics.RecordMove(1);
            CheckForInteractions(Player.Position);
        }
        return moved;
    }

    /// Проверить взаимодействия на позиции игрока
    private void CheckForInteractions(Position position)
    {
        var entitiesAtPosition = _currentLevel.GetEntitiesAt(position.X, position.Y)
                                             .Where(e => e != Player)
                                             .ToList();

        foreach (var entity in entitiesAtPosition)
        {
            if (entity is Items.Item item)
            {
                PickupItem(item);
            }
        }
    }
}





================================================
FILE: src/ProjectTeam01/domain/Session/GameSession.State.cs
================================================
namespace ProjectTeam01.domain.Session;
// отвечает за получение состояния
internal partial class GameSession
{
    /// Получить состояние игры для отображения
    public GameState GetGameState()
    {
        return new GameState
        {
            PlayerPosition = Player.Position,
            Enemies = _currentLevel.GetEnemies(),
            Items = _currentLevel.GetItems(),
            LevelGeometry = _currentLevel,
            PlayerHealth = Player.ActualHp,
            PlayerMaxHealth = Player.MaxHp,
            PlayerAgility = Player.Agility,
            PlayerStrength = Player.Strength,
            PlayerIsSleep = Player.IsHeroSleep,
            CurrentLevelNumber = _currentLevel.LevelNumber,
            // Инвентарь игрока
            PlayerWeapons = GetPlayerWeapons(),
            PlayerFood = GetPlayerFood(),
            PlayerElixirs = GetPlayerElixirs(),
            TotalGold = GetTotalGold()
        };
    }
}





================================================
FILE: src/ProjectTeam01/domain/Session/GameSession.Turn.cs
================================================
using ProjectTeam01.domain;
using ProjectTeam01.domain.Characters;
using ProjectTeam01.domain.Combat;
using ProjectTeam01.domain.Items;

namespace ProjectTeam01.domain.Session;
// отвечает за логику обработка хода
internal partial class GameSession
{
    /// Единый пошаговый ход: пока игрок не сделал ход — мир стоит.
    public void ProcessTurn(PlayerAction action)
    {
        if (action == null) return;
        if (IsGameOver() || IsGameCompleted) return;

        if (Player.IsHeroSleep)
        {
            Player.ActiveEffectManager.TickEffects();
            ProcessEnemiesTurn(skipEnemy: null);
            return;
        }

        Player.ActiveEffectManager.TickEffects();

        Enemy? enemyEngagedInCombat = null;

        switch (action.Type)
        {
            case PlayerActionType.Move:
                HandlePlayerMove(action.TargetX, action.TargetY, out enemyEngagedInCombat);
                break;
            case PlayerActionType.UseItem:
                if (action.SelectedItem != null)
                    UsePlayerItem(action.SelectedItem);
                break;
            case PlayerActionType.EquipWeapon:
                if (action.SelectedItem is Weapon weapon)
                    EquipPlayerWeapon(weapon);
                break;
            case PlayerActionType.UnequipWeapon:
                UnequipPlayerWeapon();
                break;
            case PlayerActionType.DropItem:
                if (action.SelectedItem != null)
                    DropPlayerItem(action.SelectedItem);
                break;
            case PlayerActionType.Quit:
                _gameCompleted = false;
                return;
        }

        if (Player.IsDead) return;

        if (IsPlayerAtExit())
        {
            if (IsLastLevel())
            {
                _gameCompleted = true;
                return;
            }
            AdvanceToNextLevelInternal();
            return;
        }

        ProcessEnemiesTurn(skipEnemy: enemyEngagedInCombat);
    }

    private void HandlePlayerMove(int targetX, int targetY, out Enemy? engagedEnemy)
    {
        engagedEnemy = null;

        if (!_currentLevel.IsWalkable(targetX, targetY))
            return;

        var enemy = _currentLevel.GetEntitiesAt(targetX, targetY).OfType<Enemy>().FirstOrDefault();
        if (enemy != null)
        {
            engagedEnemy = enemy;
            var result = ProcessCombat(enemy);

            if (result == CombatResult.EnemyDefeated)
                MovePlayer(targetX, targetY);

            return;
        }

        MovePlayer(targetX, targetY);
    }
}





================================================
FILE: src/ProjectTeam01/domain/Session/GameState.cs
================================================
using System.Collections.Generic;
using ProjectTeam01.domain.Characters;
using ProjectTeam01.domain.generation;
using ProjectTeam01.domain.Items;

namespace ProjectTeam01.domain.Session;

/// Состояние игры для отображения
internal class GameState
{
    public Position PlayerPosition { get; set; }
    public IReadOnlyList<Enemy> Enemies { get; set; } = new List<Enemy>().AsReadOnly();
    public IReadOnlyList<Item> Items { get; set; } = new List<Item>().AsReadOnly();
    public Level LevelGeometry { get; set; } = null!;
    public int PlayerHealth { get; set; }
    public int PlayerMaxHealth { get; set; }
    public int PlayerAgility { get; set; }
    public int PlayerStrength { get; set; }
    public bool PlayerIsSleep { get; set; }
    public int CurrentLevelNumber { get; set; }
    
    // Инвентарь игрока
    public IReadOnlyList<Weapon> PlayerWeapons { get; set; } = new List<Weapon>().AsReadOnly();
    public IReadOnlyList<Food> PlayerFood { get; set; } = new List<Food>().AsReadOnly();
    public IReadOnlyList<Elixir> PlayerElixirs { get; set; } = new List<Elixir>().AsReadOnly();
    public IReadOnlyList<Scroll> PlayerScrolls { get; set; } = new List<Scroll>().AsReadOnly();
    public int TotalGold { get; set; } = 0;
}




================================================
FILE: src/ProjectTeam01/domain/Session/GameStatistics.cs
================================================
namespace ProjectTeam01.domain.Session;

/// Статистика одной попытки прохождения
/// Данные собираются в domain и могут быть сохранены datalayer.

internal sealed class GameStatistics
{
    public int TreasuresCollected { get; private set; }
    public int MaxLevelReached { get; private set; }
    public int EnemiesDefeated { get; private set; }
    public int FoodConsumed { get; private set; }
    public int ElixirsConsumed { get; private set; }
    public int ScrollsConsumed { get; private set; }
    public int HitsLanded { get; private set; }
    public int HitsMissed { get; private set; }
    public int HitsTaken { get; private set; }
    public int CellsMoved { get; private set; }

    public GameStatistics(int startLevel = 1)
    {
        TreasuresCollected = 0;
        MaxLevelReached = startLevel;
    }

    public void RecordLevelReached(int level)
    {
        if (level > MaxLevelReached)
            MaxLevelReached = level;
    }

    public void RecordTreasureCollected(int value)
    {
        if (value > 0)
            TreasuresCollected += value;
    }

    public void RecordEnemyDefeated() => EnemiesDefeated++;
    public void RecordFoodConsumed() => FoodConsumed++;
    public void RecordElixirConsumed() => ElixirsConsumed++;
    public void RecordScrollConsumed() => ScrollsConsumed++;
    public void RecordMove(int cells = 1) { if (cells > 0) CellsMoved += cells; }
    
    /// Записать попытку попадания
    public void RecordPlayerHitAttempt(bool hit)
    {
        if (hit) HitsLanded++;
        else HitsMissed++;
    }

    /// Записать полученный урон
    public void RecordHitTaken() => HitsTaken++;

    /// Восстановить статистику из сохранения
    internal void RestoreFrom(int treasuresCollected, int maxLevelReached, int enemiesDefeated,
        int foodConsumed, int elixirsConsumed, int scrollsConsumed,
        int hitsLanded, int hitsMissed, int hitsTaken, int cellsMoved)
    {
        TreasuresCollected = treasuresCollected;
        MaxLevelReached = maxLevelReached;
        EnemiesDefeated = enemiesDefeated;
        FoodConsumed = foodConsumed;
        ElixirsConsumed = elixirsConsumed;
        ScrollsConsumed = scrollsConsumed;
        HitsLanded = hitsLanded;
        HitsMissed = hitsMissed;
        HitsTaken = hitsTaken;
        CellsMoved = cellsMoved;
    }
}





================================================
FILE: src/ProjectTeam01/presentation/GameController.cs
================================================
using ProjectTeam01.datalayer;
using ProjectTeam01.domain;
using ProjectTeam01.domain.Session;
using ProjectTeam01.presentation.Mappers;
using ProjectTeam01.presentation.ViewModels;
using ProjectTeam01.presentation.Frontend;

namespace ProjectTeam01.presentation;

/// Тонкий контроллер для связи UI и Domain.
/// Переводит ввод пользователя в PlayerAction и вызывает Domain.
internal class GameController
{
    private InputMode _inputMode = InputMode.Normal;
    public InputMode CurrentInputMode => _inputMode;

    private GameSession _session;
    private bool _running = true;
    private const string ScoreboardFilePath = "scoreboard.json";
    private const string GameSaveFilePath = "game_save.json";

    public bool Running => _running;
    public GameSession Session => _session;

    public GameController(GameSession session)
    {
        _session = session ?? throw new ArgumentNullException(nameof(session));
    }
    public PlayerAction? Translate(InputCommand command)
    {
        var pos = _session.Player.Position;

        switch (command.Type)
        {
            case InputCommandType.MoveUp:
                return PlayerAction.CreateMove(pos.X, pos.Y - 1);

            case InputCommandType.MoveDown:
                return PlayerAction.CreateMove(pos.X, pos.Y + 1);

            case InputCommandType.MoveLeft:
                return PlayerAction.CreateMove(pos.X - 1, pos.Y);

            case InputCommandType.MoveRight:
                return PlayerAction.CreateMove(pos.X + 1, pos.Y);

            case InputCommandType.WeaponMenu:
                _inputMode = InputMode.WeaponMenu;
                return null;
                // return HandleWeaponSelection();

            case InputCommandType.FoodMenu:
                _inputMode = InputMode.FoodMenu;
                return null;
                // return HandleFoodSelection();
                
            case InputCommandType.ElixirMenu:
                _inputMode = InputMode.ScrollMenu;
                return null;
                // return HandleElixirSelection();

            case InputCommandType.ScrollMenu:
                _inputMode = InputMode.ScrollMenu;
                return null;
                // return HandleScrollSelection();

            case InputCommandType.Quit:
                return PlayerAction.CreateQuit();
            default:
                return null;
        }
    }

    public bool HandleInput(char key)
    {
        PlayerAction? action = null;

        if (_inputMode == InputMode.Normal)
        {
            var command = InputHandler.Read(key);
            if (command != null)
                action = Translate(command);
        }
        else
        {
            action = HandleMenuInput(key);
        }

        if (action != null)
            ApplyAction(action);

        return _running;
    }
    /// Обработать ввод пользователя (клавиша)
    /// Возвращает true, если нужно продолжить игру, false - если выход
    // public bool HandleInput(char key)
    // {
    //     PlayerAction? action = null;

    //     // Движение
    //     if (key == 'w' || key == 'W')
    //         action = PlayerAction.CreateMove(_session.Player.Position.X, _session.Player.Position.Y - 1);
    //     else if (key == 's' || key == 'S')
    //         action = PlayerAction.CreateMove(_session.Player.Position.X, _session.Player.Position.Y + 1);
    //     else if (key == 'a' || key == 'A')
    //         action = PlayerAction.CreateMove(_session.Player.Position.X - 1, _session.Player.Position.Y);
    //     else if (key == 'd' || key == 'D')
    //         action = PlayerAction.CreateMove(_session.Player.Position.X + 1, _session.Player.Position.Y);

    //     // Инвентарь (по ТЗ: h - оружие, j - еда, k - эликсир, e - свиток)
    //     else if (key == 'h' || key == 'H')
    //         action = HandleWeaponSelection();
    //     else if (key == 'j' || key == 'J')
    //         action = HandleFoodSelection();
    //     else if (key == 'k' || key == 'K')
    //         action = HandleElixirSelection();
    //     else if (key == 'e' || key == 'E')
    //         action = HandleScrollSelection();

    //     // Выход
    //     else if (key == 'q' || key == 'Q' || key == '\x1b') // ESC
    //         action = PlayerAction.CreateQuit();

    //     if (action != null)
    //     {
    //         // Сохраняем номер уровня до хода для проверки перехода на новый уровень
    //         int levelBeforeTurn = _session.CurrentLevelNumber;

    //         _session.ProcessTurn(action);

    //         // Сохраняем полную игру при переходе на новый уровень (по ТЗ: "После прохождения каждого уровня")
    //         if (_session.CurrentLevelNumber > levelBeforeTurn)
    //         {
    //             SaveFullGame();
    //         }

    //         // Проверка выхода из игры (Quit) - сохраняем полную игру перед выходом (по ТЗ: "После перезапуска игры")
    //         if (action.Type == PlayerActionType.Quit)
    //         {
    //             SaveFullGame();
    //             _running = false;
    //             return _running;
    //         }

    //         // Проверка окончания игры
    //         if (_session.IsGameOver() || _session.IsGameCompleted)
    //         {
    //             // Добавляем попытку в таблицу лидеров при завершении игры
    //             GameDataService.AddAttemptToScoreboard(_session.Statistics, ScoreboardFilePath);
    //             _running = false;
    //         }
    //     }

    //     return _running;
    // }

    private void ApplyAction(PlayerAction action)
        {
            // Сохраняем номер уровня до хода для проверки перехода на новый уровень
            int levelBeforeTurn = _session.CurrentLevelNumber;

            _session.ProcessTurn(action);

            // Сохраняем полную игру при переходе на новый уровень (по ТЗ: "После прохождения каждого уровня")
            if (_session.CurrentLevelNumber > levelBeforeTurn)
            {
                SaveFullGame();
            }

            // Проверка выхода из игры (Quit) - сохраняем полную игру перед выходом (по ТЗ: "После перезапуска игры")
            if (action.Type == PlayerActionType.Quit)
            {
                SaveFullGame();
                _running = false;
                return;
            }

            // Проверка окончания игры
            if (_session.IsGameOver() || _session.IsGameCompleted)
            {
                // Добавляем попытку в таблицу лидеров при завершении игры
                GameDataService.AddAttemptToScoreboard(_session.Statistics, ScoreboardFilePath);
                _running = false;
            }
        }
    /// Получить представление состояния игры для фронтенда
    private PlayerAction? HandleMenuInput(char key)
    {
        if (key == '\x1b' || key == 'q')
        {
            _inputMode = InputMode.Normal;
            return null;
        }
        switch (_inputMode)
        {
            case InputMode.WeaponMenu:
                return HandleWeaponSelection(key);
            case InputMode.FoodMenu:
                return HandleFoodSelection(key);
            case InputMode.ElixirMenu:
                return HandleElixirSelection(key);
            case InputMode.ScrollMenu:
                return HandleScrollSelection(key);
        }
        return null;
    }
    public GameStateViewModel GetGameStateViewModel()
    {
        var gameState = _session.GetGameState();
        return GameStateMapper.ToViewModel(gameState);
    }

    /// Получить статистику
    public GameStatistics GetStatistics()
    {
        return _session.Statistics;
    }

    // === Обработка выбора предметов из инвентаря ===
        private PlayerAction? HandleWeaponSelection(char key)
    {
        var weapons = _session.GetPlayerWeapons();
        if (weapons.Count == 0)
            return null; // Нет оружия

        if (key == '0')
            return PlayerAction.CreateUnequipWeapon();

          else  if (key >= '1' && key <= '9')
            {
                int index = key - '1';
                if (index < weapons.Count)
                {
                    _inputMode = InputMode.Normal;
                    return PlayerAction.CreateUseItem(weapons[index]);
                }
            }

        return null;
    }

    // private PlayerAction? HandleWeaponSelection()
    // {
    //     _inputMode = InputMode.WeaponMenu;
    //     return null;
        // var weapons = _session.GetPlayerWeapons();
        // if (weapons.Count == 0)
        //     return null; // Нет оружия

        // // Показываем список (заглушка - можно заменить на полноценный View)
        // ShowItemList("Оружие (0 - снять, 1-9 - экипировать):", weapons, 0);

        // var choice = GetNumericInput(0, weapons.Count);
        // if (choice == null) return null;

        // if (choice == 0)
        //     return PlayerAction.CreateUnequipWeapon();
        // else if (choice > 0 && choice <= weapons.Count)
        //     return PlayerAction.CreateEquipWeapon(weapons[choice.Value - 1]);

        // return null;
   // }

    private PlayerAction? HandleFoodSelection(char key)
    {
        var food = _session.GetPlayerFood();
        if (food.Count == 0)
            return null;
         if (key >= '1' && key <= '9')
            {
                int index = key - '1';
                if (index < food.Count)
                {
                    _inputMode = InputMode.Normal;
                    return PlayerAction.CreateUseItem(food[index]);
                }
            }
        return null;
    }

    private PlayerAction? HandleElixirSelection(char key)
    {
        var elixirs = _session.GetPlayerElixirs();
        if (elixirs.Count == 0)
            return null;
            if (key >= '1' && key <= '9')
            {
                int index = key - '1';
                if (index < elixirs.Count)
                {
                    _inputMode = InputMode.Normal;
                    return PlayerAction.CreateUseItem(elixirs[index]);
                }
            }
        return null;
    }

    private PlayerAction? HandleScrollSelection(char key)
    {
        var scrolls = _session.GetPlayerScrolls();
        if (scrolls.Count == 0)
            return null;
        if (key >= '1' && key <= '9')
            {
                int index = key - '1';
                if (index < scrolls.Count)
                {
                    _inputMode = InputMode.Normal;
                    return PlayerAction.CreateUseItem(scrolls[index]);
                }
            }
        return null;
    }
    // private PlayerAction? HandleScrollSelection()
    // {
    //     _inputMode = InputMode.ScrollMenu;
    //     return null;
    //     // var scrolls = _session.GetPlayerScrolls();
    //     // if (scrolls.Count == 0)
    //     //     return null;

    //     // ShowItemList("Свитки (1-9 - использовать):", scrolls, 1);
    //     // var choice = GetNumericInput(1, scrolls.Count);
    //     // if (choice > 0 && choice <= scrolls.Count)
    //     //     return PlayerAction.CreateUseItem(scrolls[choice.Value - 1]);

    //     // return null;
    // }

    // === Вспомогательные методы для отображения (заглушки, можно заменить на View) ===

    // private void ShowItemList<T>(string title, IReadOnlyList<T> items, int startIndex) where T : Item
    // {
    //     Console.WriteLine($"\n{title}");
    //     for (int i = 0; i < items.Count; i++)
    //     {
    //         Console.WriteLine($"  {i + startIndex}. {GetItemName(items[i])}");
    //     }
    //     Console.Write("Выберите: ");
    // }

    // private string GetItemName(Item item)
    // {
    //     return item switch
    //     {
    //         Weapon w => $"Оружие: {w.WeaponType} (+{w.StrengthBonus} силы)",
    //         Food f => $"Еда (+{f.HealthValue} HP)",
    //         Elixir e => $"Эликсир: {e.ElixirType}",
    //         Scroll s => $"Свиток: {s.ScrollType}",
    //         Treasure t => $"Сокровище ({t.Price} золота)",
    //         _ => item.Type.ToString()
    //     };
    // }

    // private int? GetNumericInput(int min, int max)
    // {
    //     var input = Console.ReadLine();
    //     if (int.TryParse(input, out int choice) && choice >= min && choice <= max)
    //         return choice;
    //     return null;
    // }

    /// Сохранить полную игру (герой, враги, предметы, уровень, статистика)
    private void SaveFullGame()
    {
        var hero = _session.Player;
        var enemies = _session.CurrentLevel.GetEnemies().ToList();
        var items = _session.CurrentLevel.GetItems().ToList();
        var level = _session.CurrentLevel;
        var statistics = _session.Statistics;

        var save = GameDataService.CreateSave(hero, enemies, items, level, statistics);
        GameDataService.SaveToFile(save, GameSaveFilePath);
    }
}




================================================
FILE: src/ProjectTeam01/presentation/GameStateRenderer.cs
================================================
using Mindmagma.Curses;
using ProjectTeam01.domain.Characters;
using ProjectTeam01.domain.Items;
using ProjectTeam01.domain.generation;
using ProjectTeam01.presentation.ViewModels;
using ProjectTeam01.presentation.Frontend;
using ProjectTeam01.datalayer.Mappers;

namespace ProjectTeam01.presentation;
///СУЩЕСТВУЕТ СЕЙЧАС ДЛЯ СТАТИЧНОЙ ОТРИСОВКИ УРОВНЯ (УДАЛЯЕМ КОГДА ПОЯВИТСЯ РЕАЛЬНЫЙ ФРОНТ)
/// Рендерер для отрисовки состояния игры в консоль
/// Работает с ViewModels (новый подход)
internal static class GameStateRenderer
{
    /// Отрисовывает состояние игры в консоль
    public static void RenderHandler(GameStateViewModel viewModel,  nint stdscr, GameController controller,  char[,] map)
    {
        NCurses.GetMaxYX(stdscr, out int maxY, out int maxX);

        switch (controller.CurrentInputMode)
        {
            case InputMode.Normal:
                NCurses.Clear();
                RenderMap(viewModel, maxY, maxX, map);
                break;
            case InputMode.ElixirMenu:
                RenderMenu("Elexirs",viewModel.Items,maxY,maxX);
                NCurses.Clear();
                break;
        }
        NCurses.Refresh();

    }
    private static void RenderMap(GameStateViewModel viewModel, int maxY, int maxX,  char[,] map)
    {
         // Отрисовываем коридоры (сначала, чтобы они были под комнатами)
        foreach (var corridor in viewModel.Level.Corridors)
        {
            RenderCorridor(map, corridor);
        }
        // Отрисовываем комнаты
        foreach (var room in viewModel.Level.Rooms)
        {
            RenderRoom(map, room);
        }
        
        // Отрисовываем двери
        foreach (var room in viewModel.Level.Rooms)
        {
            RenderDoors(map, room);
        }
        
        // Отрисовываем стартовую позицию
        if (viewModel.Level.StartPosition.X > 0 && viewModel.Level.StartPosition.Y > 0)
        {
            map[viewModel.Level.StartPosition.Y, viewModel.Level.StartPosition.X] = 'S';
        }
        
        // Отрисовываем конечную позицию
        if (viewModel.Level.ExitPosition.X > 0 && viewModel.Level.ExitPosition.Y > 0)
        {
            map[viewModel.Level.ExitPosition.Y, viewModel.Level.ExitPosition.X] = 'E';
        }
        
        // Отрисовываем сущности (игрок, враги, предметы)
        RenderEntities(map, viewModel);
        
        // Выводим карту в консоль
        // PrintMap(map);
        PrintMapNCurses(map, maxY, maxX, viewModel);
    }
    public static void ActivateColorSystem()
    {
        NCurses.StartColor();
        NCurses.UseDefaultColors();
        if (NCurses.CanChangeColor())
        {
            NCurses.InitColor(UiColors.White,  1000, 1000, 1000);
            NCurses.InitColor(UiColors.Yellow, 1000, 1000, 0);
            NCurses.InitColor(UiColors.Red,    1000, 0, 0);
            NCurses.InitColor(UiColors.Green, 0, 1000, 0);
            NCurses.InitColor(UiColors.Blue, 0, 0, 1000);

            NCurses.InitPair(UiColors.White,  UiColors.White,  -1);
            NCurses.InitPair(UiColors.Green,  UiColors.Green,  -1);
            NCurses.InitPair(UiColors.Yellow, UiColors.Yellow, -1);
            NCurses.InitPair(UiColors.Red,    UiColors.Red,    -1);
            NCurses.InitPair(UiColors.Blue,   UiColors.Blue,   -1);
        }
    }
    
    /// Отрисовывает сущности на карте
    private static void RenderEntities(char[,] map, GameStateViewModel viewModel)
    {
        // Отрисовываем игрока
        var playerPos = viewModel.Player.Position;
        if (IsValidPosition(playerPos, map))
        {
            map[playerPos.Y, playerPos.X] = '@'; // Игрок
        }
        
        // Отрисовываем врагов
        foreach (var enemy in viewModel.Enemies)
        {
            if (enemy.IsDead) continue; // Пропускаем мертвых врагов
            if (enemy.IsInvisible == true) continue; // Пропускаем невидимых призраков
            
            var pos = enemy.Position;
            if (!IsValidPosition(pos, map)) continue;
            
            // Если на этой позиции уже есть игрок или выход, не перезаписываем
            if (map[pos.Y, pos.X] == '@' || map[pos.Y, pos.X] == 'E')
                continue;
            
            // Символ врага по типу
            char enemySymbol = GetEnemySymbol(enemy.EnemyType);
            map[pos.Y, pos.X] = enemySymbol;
            
        }
        
        // Отрисовываем предметы
        foreach (var item in viewModel.Items)
        {
            var pos = item.Position;
            if (!IsValidPosition(pos, map)) continue;
            
            // Если на этой позиции уже есть игрок, враг или выход, не перезаписываем
            if (map[pos.Y, pos.X] == '@' || map[pos.Y, pos.X] == 'E' || 
                IsEnemySymbol(map[pos.Y, pos.X]))
                continue;
            
            // Символ предмета по типу
            char itemSymbol = GetItemSymbol(item.Type);
            // Не перезаписываем пол, если это не пустое место
            if (map[pos.Y, pos.X] == '.' || map[pos.Y, pos.X] == ' ')
            {
                map[pos.Y, pos.X] = itemSymbol;
            }
        }
        NCurses.Refresh();
    }
    
    /// Получить символ врага по типу
    private static char GetEnemySymbol(EnemyTypeEnum enemyType)
    {
        return enemyType switch
        {
            EnemyTypeEnum.Zombie => 'z',
            EnemyTypeEnum.Vampire => 'v',
            EnemyTypeEnum.Ghost => 'g',
            EnemyTypeEnum.Ogre => 'O',
            EnemyTypeEnum.Snake => 's',
            EnemyTypeEnum.Mimic => 'm',
            _ => '?'
        };
    }
    
    /// Получить символ предмета
    private static char GetItemSymbol(ItemType itemType)
    {
        return itemType switch
        {
            ItemType.Treasure => '$',
            ItemType.Food => 'F',
            ItemType.Elixir => 'e',
            ItemType.Scroll => '?',
            ItemType.Weapon => 'W',
            _ => '?'
        };
    }
    
    /// Проверить, является ли символ символом врага
    private static bool IsEnemySymbol(char symbol)
    {
        return symbol == 'z' || symbol == 'v' || symbol == 'g' || 
               symbol == 'O' || symbol == 's' || symbol == 'm';
    }
    
    /// Проверить валидность позиции для отрисовки
    private static bool IsValidPosition(Position pos, char[,] map)
    {
        return pos.Y >= 0 && pos.Y < map.GetLength(0) &&
               pos.X >= 0 && pos.X < map.GetLength(1);
    }
    
    /// Отрисовывает комнату на карте
    private static void RenderRoom(char[,] map, RoomViewModel room)
    {
        int top = room.TopLeft.Y;
        int left = room.TopLeft.X;
        int bottom = room.BottomRight.Y;
        int right = room.BottomRight.X;
        
        // Отрисовываем стены и пол
        for (int y = top; y <= bottom; y++)
        {
            for (int x = left; x <= right; x++)
            {
                // Проверяем границы
                if (y < 0 || y >= GenerationConstants.MapHeight || 
                    x < 0 || x >= GenerationConstants.MapWidth)
                    continue;
                
                // Стены
                if (y == top || y == bottom || x == left || x == right)
                {
                    map[y, x] = '#';
                }
                // Пол
                else
                {
                    // Если это не коридор, рисуем пол
                    if (map[y, x] == ' ' || map[y, x] == '.')
                    {
                        map[y, x] = '.';
                    }
                }
            }
        }
    }
    
    /// Отрисовывает коридор на карте
    private static void RenderCorridor(char[,] map, CorridorViewModel corridor)
    {
        if (corridor.Cells == null || corridor.Cells.Count == 0)
            return;
        
        // Отрисовываем все клетки коридора
        foreach (var cell in corridor.Cells)
        {
            // Проверяем границы
            if (cell.Y >= 0 && cell.Y < GenerationConstants.MapHeight && 
                cell.X >= 0 && cell.X < GenerationConstants.MapWidth)
            {
                // Рисуем коридор ('.' для пола коридора)
                if (map[cell.Y, cell.X] == ' ')
                {
                    map[cell.Y, cell.X] = '.';
                }
            }
        }
    }
    
    /// Отрисовывает двери комнаты
    private static void RenderDoors(char[,] map, RoomViewModel room)
    {
        if (room.Doors == null)
            return;
        
        foreach (var door in room.Doors)
        {
            // Проверяем, что дверь инициализирована
            if (door.X > 0 && door.Y > 0)
            {
                // Проверяем границы
                if (door.Y >= 0 && door.Y < GenerationConstants.MapHeight && 
                    door.X >= 0 && door.X < GenerationConstants.MapWidth)
                {
                    // Дверь обозначаем символом '+'
                    // Но только если это не стартовая или конечная позиция
                    if (map[door.Y, door.X] != 'S' && map[door.Y, door.X] != 'E')
                    {
                        map[door.Y, door.X] = '+';
                    }
                }
            }
        }
    }

    private static void PrintMapNCurses(char[,] map,int maxY, int maxX, GameStateViewModel viewModel)
    {
        // Получаем размеры терминала

        int mapHeight = map.GetLength(0);
        int mapWidth = map.GetLength(1);

        // Ограничиваем размеры карты размером окна (без выхода за границы)
        int winHeight = Math.Min(mapHeight, maxY - 1);
        int winWidth = Math.Min(mapWidth, maxX - 1);

        // Создаем подокно строго для карты
        nint win = NCurses.NewWindow(winHeight, winWidth, 0, 0);

        // Отрисовка карты
        for (int y = 0; y < winHeight; y++)
        {
            for (int x = 0; x < winWidth; x++)
            {
                char c = map[y, x];

                // Заменяем null-символы на пробел
                if (c == '\0') c = ' ';
                uint color = GetColorForChar(c);
                // Безопасно пишем символ
                NCurses.WindowMove(win, y, x);
                if (color != 0)
                NCurses.WindowAttributeOn(win, color);
                try
                {
                    NCurses.WindowAddChar(win, c);
                }
                catch (Mindmagma.Curses.DotnetCursesException)
                {
                    // Игнорируем ошибку, чтобы программа не падала
                }
                        if (color != 0)
                NCurses.WindowAttributeOff(win, color);
            }
        }

        // Обновляем окно
        NCurses.WindowRefresh(win);

            if(winHeight+1>maxY || winWidth + 1 > maxX)
            {
                NCurses.Move(winHeight, 0);
                NCurses.AddString("Terminal is to small for stats");
                return;
            }
            else
                PrintStats(winHeight,winWidth,viewModel);
            
            int legendStartY = winHeight+2; 
            PrintLegend(legendStartY,maxX,maxY);
    }
    private static void PrintLegend(int legendStartY, int maxX, int maxY)
    {
        string[] legendLines =
        {
            "Legend:",
            "  # = Wall",
            "  . = Floor",
            "  + = Door",
            "  S = Start",
            "  E = Exit",
            "",
            "Entities:",
            "  @ = Player",
            "  z = Zombie",
            "  v = Vampire",
            "  g = Ghost",
            "  O = Ogre",
            "  s = Snake",
            "  m = Mimic",
            "  $ = Treasure",
            "  F = Food",
            "  e = Elixir",
            "  ? = Scroll",
            "  W = Weapon"
        };

        for (int i = 0; i < legendLines.Length; i++)
        {
            int y = legendStartY + i;
            if (y >= maxY) break; // не выходим за экран
            string line = legendLines[i];
            if (line.Length > maxX) line = line.Substring(0, maxX - 1); // обрезаем, если длиннее
            NCurses.Move(y, 0);
            NCurses.AddString(line);
        }
    }

    private static void PrintStats(int winHeight, int winWidth , GameStateViewModel viewModel)
    {
        int  y = winHeight+1;
        var player = viewModel.Player;

        string[] statsInfo =
        {
            $"Agil: {player.Agility}",
            $"Str: {player.Strength}",
            $"HP: {player.Health}/{player.MaxHealth}",
            $"Total gold: {viewModel.TotalGold}"
        };

        int partsWith = winWidth/statsInfo.Length;
        for(int i = 0; i < statsInfo.Length; i++)
        {
            string stat = statsInfo[i];
            int x = partsWith * i +(partsWith-stat.Length)/2;
            if(x<0) x=0;
            if(x+stat.Length >= winWidth) continue;
            NCurses.Move(y, x);
            NCurses.AddString(stat);
        }
    }
    private static uint GetColorForChar(char c)
    {
        switch (c)
        {
            case '#':
            case '.':
            case '@':
            case 'g':
            case 's':
            case '?':
                return NCurses.ColorPair(UiColors.White);
            case 'z':
                return NCurses.ColorPair(UiColors.Green);
            case 'O':
            case '$':
            case 'F':
                return NCurses.ColorPair(UiColors.Yellow);
            case 'v':
            case 'E':
                return NCurses.ColorPair(UiColors.Red);            
            case 'S':
            case 'e':
            case 'W':
                return NCurses.ColorPair(UiColors.Blue);
            default:
                return 0;
        }

    }

    private static void RenderMenu(string title,List<ItemViewModel> items, int maxY,int maxX)
    {
        int y = maxY/2;
        int x = maxX/2;
        int titleX = (maxX - title.Length) / 2;
        NCurses.Move(y, titleX);
        NCurses.AddString($"{title}");
        y++;
        for (int i = 0; i < items.Count; i++)
        {
            y = maxY/2 + i;
            if (y >= maxY) break; // не выходим за экран     
            NCurses.Move(y,x);
            NCurses.AddString($"  {i}. {(items[i].DisplayName)}");
        }
        y++;
        if (y >= maxY)
        NCurses.AddString("Выберите: ");
    }

}




================================================
FILE: src/ProjectTeam01/presentation/Frontend/InputCommand.cs
================================================
namespace ProjectTeam01.presentation.Frontend
{
    public enum InputCommandType
    {
        MoveUp,
        MoveDown,
        MoveLeft,
        MoveRight,
        WeaponMenu,
        FoodMenu,
        ElixirMenu,
        ScrollMenu,
        Quit
    }

    public class InputCommand
    {
        public InputCommandType Type { get; }

        public InputCommand(InputCommandType type)
        {
            Type = type;
        }
    }
}



================================================
FILE: src/ProjectTeam01/presentation/Frontend/InputHandler.cs
================================================
namespace ProjectTeam01.presentation.Frontend
{
    public enum InputMode
    {
        Normal,
        WeaponMenu,
        FoodMenu,
        ElixirMenu,
        ScrollMenu
    }
    public static class InputHandler
    {
        public static InputCommand? Read(char key)
        {
            if (key == 'w' || key == 'W')
                return new (InputCommandType.MoveUp);
            if (key == 's' || key == 'S')
                return new (InputCommandType.MoveDown);
            if (key == 'a' || key == 'A')
                return new (InputCommandType.MoveLeft);
            if (key == 'd' || key == 'D')
                return new (InputCommandType.MoveRight);

            if (key == 'h' || key == 'H')
                return new (InputCommandType.WeaponMenu);
            if (key == 'j' || key == 'J')
                return new (InputCommandType.FoodMenu);
            if (key == 'k' || key == 'K')
                return new (InputCommandType.ElixirMenu);
            if (key == 'e' || key == 'E')
                return new (InputCommandType.ScrollMenu);

            if (key == 'q' || key == 'Q' || key == '\x1b')
                return new (InputCommandType.Quit);

            return null;
        }
    }
}




================================================
FILE: src/ProjectTeam01/presentation/Frontend/NCursesMethods.cs
================================================
﻿using Mindmagma.Curses;

namespace ProjectTeam01.presentation.Frontend
{
    public class NCursesMethods
    {
        public static void Init(nint stdscr)
        {
            NCurses.NoEcho();
            NCurses.CBreak();
            NCurses.Keypad(stdscr, true);

            NCurses.TimeOut(50);
        }

        public static void Shutdown()
        {
            NCurses.EndWin();
        }
    }
}



================================================
FILE: src/ProjectTeam01/presentation/Frontend/UiColors.cs
================================================
namespace ProjectTeam01.presentation.Frontend
{
    public static class UiColors
    {
        public const short White = 1;
        public const short Yellow = 2;
        public const short Red = 3;
        public const short Green = 4;
        public const short Blue = 4;
    }
    
}



================================================
FILE: src/ProjectTeam01/presentation/Mappers/GameStateMapper.cs
================================================
using System.Collections.Generic;
using System.Linq;
using ProjectTeam01.domain;
using ProjectTeam01.domain.Characters;
using ProjectTeam01.domain.generation;
using ProjectTeam01.domain.Items;
using ProjectTeam01.domain.Session;
using ProjectTeam01.presentation.ViewModels;

namespace ProjectTeam01.presentation.Mappers;

/// Этот класс НЕ предназначен для прямого использования фронтендом!
/// 
/// Фронтенд должен использовать GameController.GetGameStateViewModel() для получения GameStateViewModel.
/// Этот маппер используется внутри GameController и недоступен извне (internal class).
/// 
/// Этот класс преобразует внутренние объекты игры (GameState) в простые структуры данных (ViewModels),
/// которые содержат только информацию, необходимую для отображения на экране.
/// 
/// ДЛЯ ФРОНТЕНДА - используйте GameController:
/// 1. Вызовите GameController.GetGameStateViewModel() для получения GameStateViewModel
/// 2. Используйте свойства GameStateViewModel для отрисовки игры:
///    - Player - данные игрока (HP, позиция, характеристики)
///    - Enemies - список всех врагов на уровне
///    - Items - список всех предметов на уровне
///    - Level - геометрия уровня (комнаты, коридоры, выход)
///    - CurrentLevelNumber - номер текущего уровня

internal static class GameStateMapper
{
    /// Этот метод создает полное представление состояния игры.
    /// Используйте возвращаемый объект для отрисовки всех элементов игры.

    public static GameStateViewModel ToViewModel(GameState gameState)
    {
        return new GameStateViewModel
        {
            // Игрок - основная информация о персонаже
            Player = ToPlayerViewModel(gameState),
            
            // Список всех врагов на уровне (включая мертвых)
            // ВАЖНО: проверяйте IsDead перед отрисовкой
            // IsDead - флаг смерти врага
            // MimicRepresentation - представление Mimic
            // IsInvisible - флаг невидимости Ghost
            // Position - координаты врага на карте
            // EnemyType - тип врага
            Enemies = gameState.Enemies.Select(ToEnemyViewModel).ToList(),
            
            // Список всех предметов на уровне (оружие, еда, эликсиры, свитки, сокровища)
            // Type - тип предмета
            // Position - координаты предмета на карте
            // WeaponType - тип оружия
            // StrengthBonus - бонус к силе при экипировке
            // HealthValue - количество HP, которое восстанавливает еда (5-20)
            // ElixirType - тип эффекта (BuffStrength/BuffAgility/BuffMaxHp)
            // ScrollType - тип усиления (Strength/Agility/MaxHp)
            // Price - стоимость в золоте
            Items = gameState.Items.Select(ToItemViewModel).ToList(),   
            
            // Геометрия уровня - комнаты, коридоры, позиции выхода и старта
            // Rooms - список всех комнат на уровне
            // Corridors - список всех коридоров на уровне
            // ExitPosition - координаты выхода (отрисовывайте символ 'E')
            // LevelNumber - номер уровня (для отображения в UI)
            Level = ToLevelViewModel(gameState.LevelGeometry),
            
            // Номер текущего уровня
            // CurrentLevelNumber - номер текущего уровня
            CurrentLevelNumber = gameState.CurrentLevelNumber,
            
            // Инвентарь игрока (предметы без Position)
            // Используется для отображения списка предметов в UI при выборе (клавиши h, j, k, e)
            InventoryWeapons = gameState.PlayerWeapons.Select(ToInventoryItemViewModel).ToList(),
            InventoryFood = gameState.PlayerFood.Select(ToInventoryItemViewModel).ToList(),
            InventoryElixirs = gameState.PlayerElixirs.Select(ToInventoryItemViewModel).ToList(),
            InventoryScrolls = gameState.PlayerScrolls.Select(ToInventoryItemViewModel).ToList(),
            TotalGold = gameState.TotalGold
        };
    }

    /// СВОЙСТВА:
    /// - Position: координаты игрока на карте (X, Y)
    /// - Health: текущее здоровье игрока
    /// - MaxHealth: максимальное здоровье игрока
    /// - Agility: ловкость (влияет на шанс попадания)
    /// - Strength: сила (влияет на урон)
    /// - IsSleep: true если игрок спит (не может двигаться/атаковать)
    /// 
    private static PlayerViewModel ToPlayerViewModel(GameState gameState)
    {
        return new PlayerViewModel
        {
            Position = gameState.PlayerPosition,        // Координаты для отрисовки на карте
            Health = gameState.PlayerHealth,            // Текущее HP для статус-бара
            MaxHealth = gameState.PlayerMaxHealth,      // Максимальное HP для прогресс-бара
            Agility = gameState.PlayerAgility,          // Ловкость для отображения характеристик
            Strength = gameState.PlayerStrength,        // Сила для отображения характеристик
            IsSleep = gameState.PlayerIsSleep           // Статус сна (показывать предупреждение/блокировать действия)
        };
    }


    /// Используйте эти данные для:
    /// - Отрисовки врагов на карте (разные символы для разных EnemyType)
    /// - Скрытия невидимых призраков (IsInvisible = true)
    /// - Отображения Mimic как предмета (если MimicRepresentation != Mimic)
    /// 
    /// СВОЙСТВА:
    /// - Position: координаты врага на карте
    /// - EnemyType: тип врага (Zombie, Vampire, Ghost, Ogre, Snake, Mimic)
    /// - IsDead: true если враг мертв (не отрисовывайте мертвых врагов)
    /// - IsTriggered: true если враг активирован (движется к игроку)
    /// - MimicRepresentation: только для Mimic - как он выглядит (Food/Elixir/Scroll/Weapon/Mimic)
    /// - IsInvisible: только для Ghost - true если призрак невидим (не отрисовывайте)
    /// 
    /// ПРИМЕР ОТРИСОВКИ:
    /// if (enemy.IsDead) return; // Пропускаем мертвых
    /// if (enemy.IsInvisible == true) return; // Невидимых призраков не показываем
    /// char symbol = enemy.EnemyType switch {
    ///     EnemyTypeEnum.Zombie => 'z',
    ///     EnemyTypeEnum.Vampire => 'v',
    ///     // ...
    /// };
    /// DrawAt(enemy.Position.X, enemy.Position.Y, symbol);

    private static EnemyViewModel ToEnemyViewModel(Enemy enemy)
    {
        var viewModel = new EnemyViewModel
        {
            Position = enemy.Position,          // Координаты для отрисовки
            EnemyType = enemy.EnemyType,        // Тип для выбора символа/спрайта
            IsDead = enemy.IsDead,              // Флаг смерти (не отрисовывать)
            IsTriggered = enemy.IsTriggered      // Флаг активации (враг движется к игроку)
        };

        // ОСОБЕННОСТИ MIMIC:
        // Mimic может выглядеть как предмет (Food/Elixir/Scroll/Weapon),
        // пока не активирован. Когда IsTriggered = true, Representation меняется на Mimic.
        // ДЛЯ ФРОНТЕНДА: если MimicRepresentation != Mimic, отрисовывайте его как предмет.
        if (enemy is Mimic mimic)
        {
            viewModel.MimicRepresentation = mimic.Representation;
        }

        // ОСОБЕННОСТИ GHOST:
        // Призрак может быть невидимым. Когда IsInvisible = true, его не видно на карте.
        // ДЛЯ ФРОНТЕНДА: если IsInvisible == true, не отрисовывайте этого врага.
        if (enemy is Ghost ghost)
        {
            viewModel.IsInvisible = ghost.IsInvisible;
        }

        return viewModel;
    }


    /// Используйте эти данные для:
    /// - Отрисовки предметов на карте (разные символы для разных Type)
    /// - Показывания информации о предмете при наведении/подборе
    /// - Отображения характеристик предмета (HealthValue для еды, Price для сокровищ и т.д.)
    /// 
    /// СВОЙСТВА:
    /// - Position: координаты предмета на карте
    /// - Type: тип предмета (Weapon, Food, Elixir, Scroll, Treasure)
    /// 
    /// СПЕЦИФИЧНЫЕ СВОЙСТВА (заполняются только для соответствующих типов):
    /// 
    /// ДЛЯ ОРУЖИЯ (Type = Weapon):
    /// - WeaponType: тип оружия (Sword, Bow, Staff)
    /// - StrengthBonus: бонус к силе при экипировке
    /// 
    /// ДЛЯ ЕДЫ (Type = Food):
    /// - HealthValue: количество HP, которое восстанавливает еда (5-20)
    /// 
    /// ДЛЯ ЭЛИКСИРА (Type = Elixir):
    /// - ElixirType: тип эффекта (BuffStrength, BuffAgility, BuffMaxHp)
    /// 
    /// ДЛЯ СВИТКА (Type = Scroll):
    /// - ScrollType: тип свитка (Strength, Agility, MaxHp)
    /// 
    /// ДЛЯ СОКРОВИЩА (Type = Treasure):
    /// - Price: стоимость в золоте


    private static ItemViewModel ToItemViewModel(Item item)
    {
        var viewModel = new ItemViewModel
        {
            Position = item.Position,    // Координаты для отрисовки
            Type = item.Type             // Тип для выбора символа/логики
        };

        // Заполняем специфичные свойства в зависимости от типа предмета
        switch (item)
        {
            // ОРУЖИЕ: показывает тип и бонус к силе
            case Weapon weapon:
                viewModel.WeaponType = weapon.WeaponType;           // Тип оружия для отображения
                viewModel.StrengthBonus = weapon.StrengthBonus;      // Бонус силы для UI
                viewModel.DisplayName =
                $"Оружие: {weapon.WeaponType} (+{weapon.StrengthBonus} силы)";
                break;

            // ЕДА: показывает количество восстанавливаемого HP
            case Food food:
                viewModel.HealthValue = food.HealthValue;
                viewModel.DisplayName = $"Еда: {food.HealthValue} хп)";
                break;            // HP для восстановления (5-20)
            // ЭЛИКСИР: показывает тип эффекта
            case Elixir elixir:
                viewModel.ElixirType = elixir.ElixirType;
                viewModel.DisplayName = $"Эликсир: {elixir.ElixirType})";         // Тип эффекта (BuffStrength/BuffAgility/BuffMaxHp)
                break;

            // СВИТОК: показывает тип усиления
            case Scroll scroll:
                viewModel.ScrollType = scroll.ScrollType;
                viewModel.DisplayName = $"Свиток: {scroll.ScrollType})";      // Тип усиления (Strength/Agility/MaxHp)
                break;

            // // СОКРОВИЩЕ: показывает стоимость
            // case Treasure treasure:
            //     viewModel.Price = treasure.Price;
            //     viewModel.DisplayName = $"Золото: {scroll.ScrollType})";      // Тип усиления (Strength/Agility/MaxHp)
            //                        // Стоимость в золоте
            //     break;
        }

        return viewModel;
    }

    /// Преобразует предмет из инвентаря в InventoryItemViewModel (без Position)
    /// Используется для отображения предметов в инвентаре игрока
    /// РЮКЗАК 
    private static InventoryItemViewModel ToInventoryItemViewModel(Item item)
    {
        var viewModel = new InventoryItemViewModel
        {
            Type = item.Type  // Тип для выбора символа/логики
        };

        // Заполняем специфичные свойства в зависимости от типа предмета
        switch (item)
        {
            // ОРУЖИЕ: показывает тип и бонус к силе
            case Weapon weapon:
                viewModel.WeaponType = weapon.WeaponType;           // Тип оружия для отображения
                viewModel.StrengthBonus = weapon.StrengthBonus;      // Бонус силы для UI
                break;

            // ЕДА: показывает количество восстанавливаемого HP
            case Food food:
                viewModel.HealthValue = food.HealthValue;            // HP для восстановления (5-20)
                break;

            // ЭЛИКСИР: показывает тип эффекта
            case Elixir elixir:
                viewModel.ElixirType = elixir.ElixirType;          // Тип эффекта (BuffStrength/BuffAgility/BuffMaxHp)
                break;

            // СВИТОК: показывает тип усиления
            case Scroll scroll:
                viewModel.ScrollType = scroll.ScrollType;          // Тип усиления (Strength/Agility/MaxHp)
                break;

            // СОКРОВИЩЕ: показывает стоимость
            case Treasure treasure:
                viewModel.Price = treasure.Price;                   // Стоимость в золоте
                break;
        }

        return viewModel;
    }


    /// - Отрисовки геометрии уровня (комнаты, коридоры)
    /// - Отображения стартовой позиции и выхода
    /// - Проверки проходимости клеток (IsWalkable)
    /// 
    /// СВОЙСТВА:
    /// - Rooms: список всех комнат на уровне
    /// - Corridors: список всех коридоров на уровне
    /// - ExitPosition: координаты выхода (отрисовывайте символ 'E')
    /// - StartPosition: координаты стартовой позиции (отрисовывайте символ 'S')
    /// - LevelNumber: номер уровня (для отображения в UI)
    /// 
    /// ПРИМЕР ОТРИСОВКИ:
    /// 1. Отрисуйте все комнаты (стены и пол)
    /// 2. Отрисуйте все коридоры (пол)
    /// 3. Отрисуйте двери в комнатах
    /// 4. Отрисуйте StartPosition и ExitPosition
  
    private static LevelViewModel ToLevelViewModel(Level level)
    {
        return new LevelViewModel
        {
            Rooms = level.Rooms.Select(ToRoomViewModel).ToList(),           // Комнаты для отрисовки
            Corridors = level.Corridors.Select(ToCorridorViewModel).ToList(), // Коридоры для отрисовки
            ExitPosition = level.ExitPosition,                               // Позиция выхода (символ 'E')
            StartPosition = level.StartPosition,                             // Стартовая позиция (символ 'S')
            LevelNumber = level.LevelNumber                                   // Номер уровня (для UI)
        };
    }


    /// - Отрисовки прямоугольной комнаты (стены по периметру, пол внутри)
    /// - Отображения дверей 
    /// - Выделения стартовой и конечной комнат
    /// 
    /// СВОЙСТВА:
    /// - TopLeft: левый верхний угол комнаты (X, Y)
    /// - BottomRight: правый нижний угол комнаты (X, Y)
    /// - Doors: массив позиций дверей (отрисовывайте символ '+' на каждой позиции)
    /// - IsStartRoom: true если это стартовая комната (можно выделить визуально)
    /// - IsEndRoom: true если это конечная комната (можно выделить визуально)
 
    private static RoomViewModel ToRoomViewModel(Room room)
    {
        return new RoomViewModel
        {
            TopLeft = room.TopLeft,              // Левый верхний угол для отрисовки
            BottomRight = room.BottomRight,      // Правый нижний угол для отрисовки
            // Фильтруем пустые двери (где X=0 и Y=0) - они не используются
            Doors = room.Doors.Where(d => d.X != 0 || d.Y != 0).ToArray(),
            IsStartRoom = room.IsStartRoom,      // Флаг стартовой комнаты (для выделения)
            IsEndRoom = room.IsEndRoom           // Флаг конечной комнаты (для выделения)
        };
    }


    /// - Отрисовки коридора
    /// - Определения типа коридора (для разных стилей отрисовки)
    /// 
    /// СВОЙСТВА:
    /// - Type: тип коридора (Horizontal, Vertical, LShape, TShape, Cross)
    /// - Cells: список всех клеток коридора (отрисовывайте символ '.' на каждой)

    private static CorridorViewModel ToCorridorViewModel(Corridor corridor)
    {
        return new CorridorViewModel
        {
            Type = corridor.Type,                    // Тип коридора (для стилизации)
            Cells = corridor.Cells.ToList()          // Все клетки коридора для отрисовки
        };
    }
}




================================================
FILE: src/ProjectTeam01/presentation/ViewModels/CorridorViewModel.cs
================================================
using System.Collections.Generic;
using ProjectTeam01.domain.generation;

namespace ProjectTeam01.presentation.ViewModels;

/// Представление коридора для отображения на фронтенде
public class CorridorViewModel
{
    public CorridorType Type { get; set; }
    public List<Position> Cells { get; set; } = new();
}




================================================
FILE: src/ProjectTeam01/presentation/ViewModels/EnemyViewModel.cs
================================================
using ProjectTeam01.domain.Characters;
using ProjectTeam01.domain.generation;

namespace ProjectTeam01.presentation.ViewModels;

/// Представление врага для отображения на фронтенде
public class EnemyViewModel
{
    public Position Position { get; set; }
    public EnemyTypeEnum EnemyType { get; set; }
    public bool IsDead { get; set; }
    public bool IsTriggered { get; set; }
    
    // Специфичные свойства для Mimic
    public MimicsRepresentation? MimicRepresentation { get; set; }
    
    // Специфичные свойства для Ghost
    public bool? IsInvisible { get; set; }
}




================================================
FILE: src/ProjectTeam01/presentation/ViewModels/GameStateViewModel.cs
================================================
using System.Collections.Generic;

namespace ProjectTeam01.presentation.ViewModels;

/// Представление состояния игры для отображения на фронтенде
public class GameStateViewModel
{
    public PlayerViewModel Player { get; set; } = null!;
    public List<EnemyViewModel> Enemies { get; set; } = new();
    public List<ItemViewModel> Items { get; set; } = new(); // Предметы на карте (с Position)
    public LevelViewModel Level { get; set; } = null!;
    public int CurrentLevelNumber { get; set; }
    
    // Инвентарь игрока (предметы без Position)
    public List<InventoryItemViewModel> InventoryWeapons { get; set; } = new();
    public List<InventoryItemViewModel> InventoryFood { get; set; } = new();
    public List<InventoryItemViewModel> InventoryElixirs { get; set; } = new();
    public List<InventoryItemViewModel> InventoryScrolls { get; set; } = new();

    public int TotalGold{get;set;} = 0;
}




================================================
FILE: src/ProjectTeam01/presentation/ViewModels/InventoryItemViewModel.cs
================================================
using ProjectTeam01.domain.Items;
using ProjectTeam01.domain.Effects;

namespace ProjectTeam01.presentation.ViewModels;

/// Представление предмета из инвентаря игрока для отображения на фронтенде
/// Отличается от ItemViewModel тем, что не содержит Position (предметы в инвентаре не имеют позиции на карте)
public class InventoryItemViewModel
{
    public ItemType Type { get; set; }
    
    // Специфичные свойства для разных типов предметов
    public WeaponTypeEnum? WeaponType { get; set; }
    public int? StrengthBonus { get; set; }
    
    public int? HealthValue { get; set; } // Для Food
    
    public EffectTypeEnum? ElixirType { get; set; } // Для Elixir
    
    public ScrollTypeEnum? ScrollType { get; set; } // Для Scroll
    
    public int? Price { get; set; } // Для Treasure
}




================================================
FILE: src/ProjectTeam01/presentation/ViewModels/ItemViewModel.cs
================================================
using ProjectTeam01.domain.Items;
using ProjectTeam01.domain.generation;
using ProjectTeam01.domain.Effects;

namespace ProjectTeam01.presentation.ViewModels;

/// Представление предмета для отображения на фронтенде
public class ItemViewModel
{
    public Position Position { get; set; }
    public ItemType Type { get; set; }
    
    public string DisplayName { get; set; } = string.Empty;

    // Специфичные свойства для разных типов предметов
    public WeaponTypeEnum? WeaponType { get; set; }
    public int? StrengthBonus { get; set; }
    
    public int? HealthValue { get; set; } // Для Food
    
    public EffectTypeEnum? ElixirType { get; set; } // Для Elixir
    
    public ScrollTypeEnum? ScrollType { get; set; } // Для Scroll
    
    public int? Price { get; set; } // Для Treasure
}




================================================
FILE: src/ProjectTeam01/presentation/ViewModels/LevelViewModel.cs
================================================
using System.Collections.Generic;
using ProjectTeam01.domain.generation;

namespace ProjectTeam01.presentation.ViewModels;

/// Представление уровня для отображения на фронтенде
public class LevelViewModel
{
    public List<RoomViewModel> Rooms { get; set; } = new();
    public List<CorridorViewModel> Corridors { get; set; } = new();
    public Position ExitPosition { get; set; }
    public Position StartPosition { get; set; }
    public int LevelNumber { get; set; }
}




================================================
FILE: src/ProjectTeam01/presentation/ViewModels/PlayerViewModel.cs
================================================
using ProjectTeam01.domain.generation;

namespace ProjectTeam01.presentation.ViewModels;

/// Представление игрока для отображения на фронтенде
public class PlayerViewModel
{
    public Position Position { get; set; }
    public int Health { get; set; }
    public int MaxHealth { get; set; }
    public int Agility { get; set; }
    public int Strength { get; set; }
    public bool IsSleep { get; set; }
}




================================================
FILE: src/ProjectTeam01/presentation/ViewModels/RoomViewModel.cs
================================================
using System;
using ProjectTeam01.domain.generation;

namespace ProjectTeam01.presentation.ViewModels;

/// Представление комнаты для отображения на фронтенде
public class RoomViewModel
{
    public Position TopLeft { get; set; }
    public Position BottomRight { get; set; }
    public Position[] Doors { get; set; } = Array.Empty<Position>();
    public bool IsStartRoom { get; set; }
    public bool IsEndRoom { get; set; }
}



